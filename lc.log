01:03:17 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[!!get(g:, 'LanguageClient_autoStart', 1), get(g:, 'LanguageClient_serverCommands', {}), get(g:, 'LanguageClient_selectionUI', v:null), get(g:, 'LanguageClient_trace', v:null), expand(get(g:, 'LanguageClient_settingsPath', '.vim/settings.json')), !!get(g:, 'LanguageClient_loadSettings', 1), get(g:, 'LanguageClient_rootMarkers', v:null), get(g:, 'LanguageClient_changeThrottle', v:null), get(g:, 'LanguageClient_waitOutputTimeout', v:null), !!get(g:, 'LanguageClient_diagnosticsEnable', 1), get(g:, 'LanguageClient_diagnosticsList', 'Quickfix'), get(g:, 'LanguageClient_diagnosticsDisplay', {}), get(g:, 'LanguageClient_windowLogMessageLevel', 'Warning'), get(g:, 'LanguageClient_hoverPreview', 'Auto'), get(g:, 'LanguageClient_completionPreferTextEdit', 0), has('nvim')]"],"id":25547}
01:03:17 INFO reader-main src/vim.rs:380 <= None {"id": 25547, "jsonrpc": "2.0", "result": [1, {"reason": ["ocaml-language-server", "--stdio"], "javascript.jsx": ["flow-language-server", "--stdio"], "typescript": ["javascript-typescript-stdio"], "haskell": ["hie-wrapper"], "elm": ["elm-language-server-exe"], "rust": ["rls"], "javascript": ["flow-language-server", "--stdio"], "ocaml": ["ocaml-language-server", "--stdio"], "typescript.jsx": ["javascript-typescript-stdio"]}, null, null, ".vim/settings.json", 1, {"reason": ["bs.config"], "haskell": ["stack.yaml"], "elm": ["elm.json"], "rust": ["Cargo.toml"], "javascript": ["package.json"], "ocaml": ["*.opam"]}, null, null, 1, "Quickfix", {}, "Warning", "Auto", 0, 1]}
01:03:17 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[get(g:, 'LanguageClient_diagnosticsSignsMax', v:null), get(g:, 'LanguageClient_documentHighlightDisplay', {})]"],"id":25548}
01:03:17 INFO reader-main src/vim.rs:380 <= None {"id": 25548, "jsonrpc": "2.0", "result": [null, {}]}
01:03:17 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["get(g:, 'loaded_fzf')"],"id":25549}
01:03:17 INFO reader-main src/vim.rs:380 <= None {"id": 25549, "jsonrpc": "2.0", "result": 1}
01:03:17 WARN main src/languageclient.rs:2159 Failed to start language server automatically. No language server command found for file type: yaml.
01:03:17 INFO main src/languageclient.rs:2164 End languageClient/handleBufReadPost
01:03:17 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "yaml", "line": 0, "LSP#visible_line_start()": 0, "LSP#visible_line_end()": 48, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml"}}
01:03:17 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:17 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml"), Number(0)]
01:03:17 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(48)]
01:03:17 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:17 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "yaml", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml"}}
01:03:17 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:03:17 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml")]
01:03:17 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:03:17 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("yaml"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml")]
01:03:17 INFO main src/languageclient.rs:1764 Not opened yet. Switching to didOpen.
01:03:17 INFO main src/languageclient.rs:1706 Begin textDocument/didOpen
01:03:17 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:03:17 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25550}
01:03:17 INFO reader-main src/vim.rs:380 <= None {"id": 25550, "jsonrpc": "2.0", "result": [["name:                elm-language-server", "version:             0.0.1", "github:              \"jaredramirez/elm-language-server\"", "license:             BSD3", "author:              \"Jared Ramirez\"", "maintainer:          \"jaredramirez@me.com\"", "copyright:           \"2018 Jared Ramirez\"", "", "extra-source-files:", "- README.md", "- ChangeLog.md", "", "# Metadata used when publishing your package", "# synopsis:            Short description of your package", "# category:            Web", "", "# To avoid duplicated efforts in documentation and dealing with the", "# complications of embedding Haddock markup inside cabal files, it is", "# common to point users to the README.md file.", "description:         Please see the README on GitHub at <https://github.com/jaredramirez/elm-language-server#readme>", "", "dependencies:", "- base >= 4.7 && < 5", "- text", "- aeson", "- aeson-utils", "- scientific", "- unordered-containers", "- bytestring", "- directory", "", "library:", "  source-dirs: src", "", "executables:", "  elm-language-server-exe:", "    main:                Main.hs", "    source-dirs:         app", "    ghc-options:", "    - -threaded", "    - -rtsopts", "    - -with-rtsopts=-N", "    dependencies:", "    - elm-language-server", "", "tests:", "  elm-language-server-test:", "    main:                Spec.hs", "    source-dirs:         test", "    ghc-options:", "    - -threaded", "    - -rtsopts", "    - -with-rtsopts=-N", "    dependencies:", "    - elm-language-server", ""]]}
01:03:17 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename, Text] = [String(""), String("yaml"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml"), Array([String("name:                elm-language-server"), String("version:             0.0.1"), String("github:              \"jaredramirez/elm-language-server\""), String("license:             BSD3"), String("author:              \"Jared Ramirez\""), String("maintainer:          \"jaredramirez@me.com\""), String("copyright:           \"2018 Jared Ramirez\""), String(""), String("extra-source-files:"), String("- README.md"), String("- ChangeLog.md"), String(""), String("# Metadata used when publishing your package"), String("# synopsis:            Short description of your package"), String("# category:            Web"), String(""), String("# To avoid duplicated efforts in documentation and dealing with the"), String("# complications of embedding Haddock markup inside cabal files, it is"), String("# common to point users to the README.md file."), String("description:         Please see the README on GitHub at <https://github.com/jaredramirez/elm-language-server#readme>"), String(""), String("dependencies:"), String("- base >= 4.7 && < 5"), String("- text"), String("- aeson"), String("- aeson-utils"), String("- scientific"), String("- unordered-containers"), String("- bytestring"), String("- directory"), String(""), String("library:"), String("  source-dirs: src"), String(""), String("executables:"), String("  elm-language-server-exe:"), String("    main:                Main.hs"), String("    source-dirs:         app"), String("    ghc-options:"), String("    - -threaded"), String("    - -rtsopts"), String("    - -with-rtsopts=-N"), String("    dependencies:"), String("    - elm-language-server"), String(""), String("tests:"), String("  elm-language-server-test:"), String("    main:                Spec.hs"), String("    source-dirs:         test"), String("    ghc-options:"), String("    - -threaded"), String("    - -rtsopts"), String("    - -with-rtsopts=-N"), String("    dependencies:"), String("    - elm-language-server"), String("")])]
01:03:17 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml: null ==> {"languageId":"yaml","text":"name:                elm-language-server\nversion:             0.0.1\ngithub:              \"jaredramirez/elm-language-server\"\nlicense:             BSD3\nauthor:              \"Jared Ramirez\"\nmaintainer:          \"jaredramirez@me.com\"\ncopyright:           \"2018 Jared Ramirez\"\n\nextra-source-files:\n- README.md\n- ChangeLog.md\n\n# Metadata used when publishing your package\n# synopsis:            Short description of your package\n# category:            Web\n\n# To avoid duplicated efforts in documentation and dealing with the\n# complications of embedding Haddock markup inside cabal files, it is\n# common to point users to the README.md file.\ndescription:         Please see the README on GitHub at <https://github.com/jaredramirez/elm-language-server#readme>\n\ndependencies:\n- base >= 4.7 && < 5\n- text\n- aeson\n- aeson-utils\n- scientific\n- unordered-containers\n- bytestring\n- directory\n\nlibrary:\n  source-dirs: src\n\nexecutables:\n  elm-language-server-exe:\n    main:                Main.hs\n    source-dirs:         app\n    ghc-options:\n    - -threaded\n    - -rtsopts\n    - -with-rtsopts=-N\n    dependencies:\n    - elm-language-server\n\ntests:\n  elm-language-server-test:\n    main:                Spec.hs\n    source-dirs:         test\n    ghc-options:\n    - -threaded\n    - -rtsopts\n    - -with-rtsopts=-N\n    dependencies:\n    - elm-language-server\n","uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml","version":0}
01:03:17 INFO main src/vim.rs:92 => Some("yaml") {"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"languageId":"yaml","text":"name:                elm-language-server\nversion:             0.0.1\ngithub:              \"jaredramirez/elm-language-server\"\nlicense:             BSD3\nauthor:              \"Jared Ramirez\"\nmaintainer:          \"jaredramirez@me.com\"\ncopyright:           \"2018 Jared Ramirez\"\n\nextra-source-files:\n- README.md\n- ChangeLog.md\n\n# Metadata used when publishing your package\n# synopsis:            Short description of your package\n# category:            Web\n\n# To avoid duplicated efforts in documentation and dealing with the\n# complications of embedding Haddock markup inside cabal files, it is\n# common to point users to the README.md file.\ndescription:         Please see the README on GitHub at <https://github.com/jaredramirez/elm-language-server#readme>\n\ndependencies:\n- base >= 4.7 && < 5\n- text\n- aeson\n- aeson-utils\n- scientific\n- unordered-containers\n- bytestring\n- directory\n\nlibrary:\n  source-dirs: src\n\nexecutables:\n  elm-language-server-exe:\n    main:                Main.hs\n    source-dirs:         app\n    ghc-options:\n    - -threaded\n    - -rtsopts\n    - -with-rtsopts=-N\n    dependencies:\n    - elm-language-server\n\ntests:\n  elm-language-server-test:\n    main:                Spec.hs\n    source-dirs:         test\n    ghc-options:\n    - -threaded\n    - -rtsopts\n    - -with-rtsopts=-N\n    dependencies:\n    - elm-language-server\n","uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml","version":0}}}
01:03:18 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "yaml", "line": 26, "LSP#visible_line_start()": 2, "LSP#visible_line_end()": 50, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml"}}
01:03:18 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:18 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml"), Number(26)]
01:03:18 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(2), Number(50)]
01:03:18 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:19 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "yaml", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml"}}
01:03:19 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:03:19 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml")]
01:03:19 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:03:19 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("yaml"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml")]
01:03:19 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:03:19 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25551}
01:03:19 INFO reader-main src/vim.rs:380 <= None {"id": 25551, "jsonrpc": "2.0", "result": [["name:                elm-language-server", "version:             0.0.1", "github:              \"jaredramirez/elm-language-server\"", "license:             BSD3", "author:              \"Jared Ramirez\"", "maintainer:          \"jaredramirez@me.com\"", "copyright:           \"2018 Jared Ramirez\"", "", "extra-source-files:", "- README.md", "- ChangeLog.md", "", "# Metadata used when publishing your package", "# synopsis:            Short description of your package", "# category:            Web", "", "# To avoid duplicated efforts in documentation and dealing with the", "# complications of embedding Haddock markup inside cabal files, it is", "# common to point users to the README.md file.", "description:         Please see the README on GitHub at <https://github.com/jaredramirez/elm-language-server#readme>", "", "dependencies:", "- base >= 4.7 && < 5", "- text", "- aeson", "- aeson-utils", "- unordered-containers", "- bytestring", "- directory", "", "library:", "  source-dirs: src", "", "executables:", "  elm-language-server-exe:", "    main:                Main.hs", "    source-dirs:         app", "    ghc-options:", "    - -threaded", "    - -rtsopts", "    - -with-rtsopts=-N", "    dependencies:", "    - elm-language-server", "", "tests:", "  elm-language-server-test:", "    main:                Spec.hs", "    source-dirs:         test", "    ghc-options:", "    - -threaded", "    - -rtsopts", "    - -with-rtsopts=-N", "    dependencies:", "    - elm-language-server", ""]]}
01:03:19 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("name:                elm-language-server"), String("version:             0.0.1"), String("github:              \"jaredramirez/elm-language-server\""), String("license:             BSD3"), String("author:              \"Jared Ramirez\""), String("maintainer:          \"jaredramirez@me.com\""), String("copyright:           \"2018 Jared Ramirez\""), String(""), String("extra-source-files:"), String("- README.md"), String("- ChangeLog.md"), String(""), String("# Metadata used when publishing your package"), String("# synopsis:            Short description of your package"), String("# category:            Web"), String(""), String("# To avoid duplicated efforts in documentation and dealing with the"), String("# complications of embedding Haddock markup inside cabal files, it is"), String("# common to point users to the README.md file."), String("description:         Please see the README on GitHub at <https://github.com/jaredramirez/elm-language-server#readme>"), String(""), String("dependencies:"), String("- base >= 4.7 && < 5"), String("- text"), String("- aeson"), String("- aeson-utils"), String("- unordered-containers"), String("- bytestring"), String("- directory"), String(""), String("library:"), String("  source-dirs: src"), String(""), String("executables:"), String("  elm-language-server-exe:"), String("    main:                Main.hs"), String("    source-dirs:         app"), String("    ghc-options:"), String("    - -threaded"), String("    - -rtsopts"), String("    - -with-rtsopts=-N"), String("    dependencies:"), String("    - elm-language-server"), String(""), String("tests:"), String("  elm-language-server-test:"), String("    main:                Spec.hs"), String("    source-dirs:         test"), String("    ghc-options:"), String("    - -threaded"), String("    - -rtsopts"), String("    - -with-rtsopts=-N"), String("    dependencies:"), String("    - elm-language-server"), String("")])]
01:03:19 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml.text: "name:                elm-language-server\nversion:             0.0.1\ngithub:              \"jaredramirez/elm-language-server\"\nlicense:             BSD3\nauthor:              \"Jared Ramirez\"\nmaintainer:          \"jaredramirez@me.com\"\ncopyright:           \"2018 Jared Ramirez\"\n\nextra-source-files:\n- README.md\n- ChangeLog.md\n\n# Metadata used when publishing your package\n# synopsis:            Short description of your package\n# category:            Web\n\n# To avoid duplicated efforts in documentation and dealing with the\n# complications of embedding Haddock markup inside cabal files, it is\n# common to point users to the README.md file.\ndescription:         Please see the README on GitHub at <https://github.com/jaredramirez/elm-language-server#readme>\n\ndependencies:\n- base >= 4.7 && < 5\n- text\n- aeson\n- aeson-utils\n- scientific\n- unordered-containers\n- bytestring\n- directory\n\nlibrary:\n  source-dirs: src\n\nexecutables:\n  elm-language-server-exe:\n    main:                Main.hs\n    source-dirs:         app\n    ghc-options:\n    - -threaded\n    - -rtsopts\n    - -with-rtsopts=-N\n    dependencies:\n    - elm-language-server\n\ntests:\n  elm-language-server-test:\n    main:                Spec.hs\n    source-dirs:         test\n    ghc-options:\n    - -threaded\n    - -rtsopts\n    - -with-rtsopts=-N\n    dependencies:\n    - elm-language-server\n" ==> "name:                elm-language-server\nversion:             0.0.1\ngithub:              \"jaredramirez/elm-language-server\"\nlicense:             BSD3\nauthor:              \"Jared Ramirez\"\nmaintainer:          \"jaredramirez@me.com\"\ncopyright:           \"2018 Jared Ramirez\"\n\nextra-source-files:\n- README.md\n- ChangeLog.md\n\n# Metadata used when publishing your package\n# synopsis:            Short description of your package\n# category:            Web\n\n# To avoid duplicated efforts in documentation and dealing with the\n# complications of embedding Haddock markup inside cabal files, it is\n# common to point users to the README.md file.\ndescription:         Please see the README on GitHub at <https://github.com/jaredramirez/elm-language-server#readme>\n\ndependencies:\n- base >= 4.7 && < 5\n- text\n- aeson\n- aeson-utils\n- unordered-containers\n- bytestring\n- directory\n\nlibrary:\n  source-dirs: src\n\nexecutables:\n  elm-language-server-exe:\n    main:                Main.hs\n    source-dirs:         app\n    ghc-options:\n    - -threaded\n    - -rtsopts\n    - -with-rtsopts=-N\n    dependencies:\n    - elm-language-server\n\ntests:\n  elm-language-server-test:\n    main:                Spec.hs\n    source-dirs:         test\n    ghc-options:\n    - -threaded\n    - -rtsopts\n    - -with-rtsopts=-N\n    dependencies:\n    - elm-language-server\n"
01:03:19 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml.version: 0 ==> 1
01:03:19 INFO main src/vim.rs:92 => Some("yaml") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"name:                elm-language-server\nversion:             0.0.1\ngithub:              \"jaredramirez/elm-language-server\"\nlicense:             BSD3\nauthor:              \"Jared Ramirez\"\nmaintainer:          \"jaredramirez@me.com\"\ncopyright:           \"2018 Jared Ramirez\"\n\nextra-source-files:\n- README.md\n- ChangeLog.md\n\n# Metadata used when publishing your package\n# synopsis:            Short description of your package\n# category:            Web\n\n# To avoid duplicated efforts in documentation and dealing with the\n# complications of embedding Haddock markup inside cabal files, it is\n# common to point users to the README.md file.\ndescription:         Please see the README on GitHub at <https://github.com/jaredramirez/elm-language-server#readme>\n\ndependencies:\n- base >= 4.7 && < 5\n- text\n- aeson\n- aeson-utils\n- unordered-containers\n- bytestring\n- directory\n\nlibrary:\n  source-dirs: src\n\nexecutables:\n  elm-language-server-exe:\n    main:                Main.hs\n    source-dirs:         app\n    ghc-options:\n    - -threaded\n    - -rtsopts\n    - -with-rtsopts=-N\n    dependencies:\n    - elm-language-server\n\ntests:\n  elm-language-server-test:\n    main:                Spec.hs\n    source-dirs:         test\n    ghc-options:\n    - -threaded\n    - -rtsopts\n    - -with-rtsopts=-N\n    dependencies:\n    - elm-language-server\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml","version":1}}}
01:03:20 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 29, "LSP#visible_line_start()": 5, "LSP#visible_line_end()": 53, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:20 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:20 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(29)]
01:03:20 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(5), Number(53)]
01:03:20 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:21 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 15, "LSP#visible_line_start()": 0, "LSP#visible_line_end()": 48, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:21 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:21 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(15)]
01:03:21 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(48)]
01:03:21 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:EchoEllipsis","params":["[Error]Could not find module ‘Data.Scientific’ Use -v to see a list of the files searched for."]}
01:03:21 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:21 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:21 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:03:21 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:21 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:03:21 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:21 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:03:21 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25552}
01:03:21 INFO reader-main src/vim.rs:380 <= None {"id": 25552, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Scientific (Scientific)", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: Scientific -> Int", "scientifictToInt num =", "  case AUtils.floatingOrInteger num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:03:21 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Scientific (Scientific)"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: Scientific -> Int"), String("scientifictToInt num ="), String("  case AUtils.floatingOrInteger num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:03:21 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Scientific         (Scientific)\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: Scientific -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Scientific (Scientific)\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: Scientific -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:03:21 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 620 ==> 621
01:03:21 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Scientific (Scientific)\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: Scientific -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":621}}}
01:03:21 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:03:21 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:03:21 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[{"severity":1,"range":{"start":{"line":15,"character":0},"end":{"line":15,"character":53}},"source":"ghcmod","message":"Could not find module ‘Data.Scientific’\nUse -v to see a list of the files searched for."}]},"method":"textDocument/publishDiagnostics"}
01:03:21 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:03:21 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":1,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":16,"nr":null,"text":"Could not find module ‘Data.Scientific’\nUse -v to see a list of the files searched for.","type":"E"}],"r"],"id":25553}
01:03:21 INFO reader-main src/vim.rs:380 <= None {"id": 25553, "jsonrpc": "2.0", "result": 0}
01:03:21 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25554}
01:03:21 INFO reader-main src/vim.rs:380 <= None {"id": 25554, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:03:21 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:21 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:03:21 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25555}
01:03:21 INFO reader-main src/vim.rs:380 <= None {"id": 25555, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 15]}
01:03:21 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(15)]
01:03:21 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:03:21 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25556}
01:03:21 INFO reader-main src/vim.rs:380 <= None {"id": 25556, "jsonrpc": "2.0", "result": [0, 48]}
01:03:21 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(48)]
01:03:21 INFO main src/languageclient.rs:2270 Updating signs: ["sign unplace 75060 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", "sign place 75060 line=16 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"]
01:03:21 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"execute","params":["sign unplace 75060 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","sign place 75060 line=16 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"],"id":25557}
01:03:21 INFO reader-main src/vim.rs:380 <= None {"id": 25557, "jsonrpc": "2.0", "result": 0}
01:03:21 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"nvim_buf_clear_highlight","params":[0,1,0,48]}
01:03:21 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:AddHighlights","params":[1,[{"character_end":53,"character_start":0,"group":"ALEError","line":15,"text":""}]]}
01:03:21 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:21 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:03:21 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:03:21 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 31, "LSP#visible_line_start()": 7, "LSP#visible_line_end()": 55, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:21 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:21 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(31)]
01:03:21 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(7), Number(55)]
01:03:21 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:EchoEllipsis","params":[""]}
01:03:21 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:21 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:21 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:03:21 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:21 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:03:21 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:21 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:03:21 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25558}
01:03:21 INFO reader-main src/vim.rs:380 <= None {"id": 25558, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Scientific (Scientific)", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: scientifict -> Int", "scientifictToInt num =", "  case AUtils.floatingOrInteger num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:03:21 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Scientific (Scientific)"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: scientifict -> Int"), String("scientifictToInt num ="), String("  case AUtils.floatingOrInteger num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:03:21 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 621 ==> 622
01:03:21 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Scientific (Scientific)\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: Scientific -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Scientific (Scientific)\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifict -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:03:21 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Scientific (Scientific)\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifict -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":622}}}
01:03:21 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:03:21 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:03:21 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 15, "LSP#visible_line_start()": 0, "LSP#visible_line_end()": 48, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:21 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:21 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(15)]
01:03:21 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(48)]
01:03:21 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:EchoEllipsis","params":["[Error]Could not find module ‘Data.Scientific’ Use -v to see a list of the files searched for."]}
01:03:21 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:21 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:21 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:03:21 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:21 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:03:21 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:21 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:03:21 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25559}
01:03:21 INFO reader-main src/vim.rs:380 <= None {"id": 25559, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Scientific", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: scientifict -> Int", "scientifictToInt num =", "  case AUtils.floatingOrInteger num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:03:21 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Scientific"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: scientifict -> Int"), String("scientifictToInt num ="), String("  case AUtils.floatingOrInteger num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:03:21 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Scientific (Scientific)\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifict -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Scientific\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifict -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:03:21 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 622 ==> 623
01:03:21 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Scientific\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifict -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":623}}}
01:03:21 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:03:21 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:03:21 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:21 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:03:21 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:21 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:03:21 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:21 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:03:21 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25560}
01:03:21 INFO reader-main src/vim.rs:380 <= None {"id": 25560, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: scientifict -> Int", "scientifictToInt num =", "  case AUtils.floatingOrInteger num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:03:21 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data."), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: scientifict -> Int"), String("scientifictToInt num ="), String("  case AUtils.floatingOrInteger num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:03:21 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 623 ==> 624
01:03:21 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Scientific\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifict -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifict -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:03:21 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifict -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":624}}}
01:03:21 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:03:21 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:03:22 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:22 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:03:22 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:22 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:03:22 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:22 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25561}
01:03:22 INFO reader-main src/vim.rs:380 <= None {"id": 25561, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: scientifict -> Int", "scientifictToInt num =", "  case AUtils.floatingOrInteger num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:03:22 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: scientifict -> Int"), String("scientifictToInt num ="), String("  case AUtils.floatingOrInteger num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:03:22 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifict -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifict -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:03:22 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 624 ==> 625
01:03:22 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifict -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":625}}}
01:03:22 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:03:22 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:03:22 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:22 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:03:22 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:22 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:03:22 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:22 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25562}
01:03:22 INFO reader-main src/vim.rs:380 <= None {"id": 25562, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: scientifict -> Int", "scientifictToInt num =", "  case AUtils.floatingOrInteger num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:03:22 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: scientifict -> Int"), String("scientifictToInt num ="), String("  case AUtils.floatingOrInteger num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:03:22 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 625 ==> 626
01:03:22 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifict -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifict -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:03:22 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifict -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":626}}}
01:03:22 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:03:22 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:03:22 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[]},"method":"textDocument/publishDiagnostics"}
01:03:22 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[],"r"],"id":25563}
01:03:22 INFO reader-main src/vim.rs:380 <= None {"id": 25563, "jsonrpc": "2.0", "result": 0}
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25564}
01:03:22 INFO reader-main src/vim.rs:380 <= None {"id": 25564, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:03:22 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:22 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25565}
01:03:22 INFO reader-main src/vim.rs:380 <= None {"id": 25565, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 15]}
01:03:22 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(15)]
01:03:22 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25566}
01:03:22 INFO reader-main src/vim.rs:380 <= None {"id": 25566, "jsonrpc": "2.0", "result": [0, 48]}
01:03:22 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(48)]
01:03:22 INFO main src/languageclient.rs:2270 Updating signs: ["sign unplace 75060 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"]
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"execute","params":["sign unplace 75060 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"],"id":25567}
01:03:22 INFO reader-main src/vim.rs:380 <= None {"id": 25567, "jsonrpc": "2.0", "result": 0}
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"nvim_buf_clear_highlight","params":[0,1,0,48]}
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:AddHighlights","params":[1,[]]}
01:03:22 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:03:22 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:03:22 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 42, "LSP#visible_line_start()": 12, "LSP#visible_line_end()": 60, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:22 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:22 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(42)]
01:03:22 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:EchoEllipsis","params":[""]}
01:03:22 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:22 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:22 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:03:22 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:22 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:03:22 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:22 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25568}
01:03:22 INFO reader-main src/vim.rs:380 <= None {"id": 25568, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: scientifict -> Int", "scientifictToInt num =", "  case AUtils.floatingOrInteger num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |>  scientifictToInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:03:22 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: scientifict -> Int"), String("scientifictToInt num ="), String("  case AUtils.floatingOrInteger num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |>  scientifictToInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:03:22 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifict -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage (num |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifict -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |>  scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:03:22 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 626 ==> 627
01:03:22 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifict -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |>  scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":627}}}
01:03:22 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:03:22 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:03:22 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[]},"method":"textDocument/publishDiagnostics"}
01:03:22 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[],"r"],"id":25569}
01:03:22 INFO reader-main src/vim.rs:380 <= None {"id": 25569, "jsonrpc": "2.0", "result": 0}
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25570}
01:03:22 INFO reader-main src/vim.rs:380 <= None {"id": 25570, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:03:22 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:22 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25571}
01:03:22 INFO reader-main src/vim.rs:380 <= None {"id": 25571, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 42]}
01:03:22 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(42)]
01:03:22 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25572}
01:03:22 INFO reader-main src/vim.rs:380 <= None {"id": 25572, "jsonrpc": "2.0", "result": [12, 60]}
01:03:22 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:03:22 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:03:22 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:03:22 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[]},"method":"textDocument/publishDiagnostics"}
01:03:22 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[],"r"],"id":25573}
01:03:22 INFO reader-main src/vim.rs:380 <= None {"id": 25573, "jsonrpc": "2.0", "result": 0}
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25574}
01:03:22 INFO reader-main src/vim.rs:380 <= None {"id": 25574, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:03:22 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:22 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25575}
01:03:22 INFO reader-main src/vim.rs:380 <= None {"id": 25575, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 42]}
01:03:22 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(42)]
01:03:22 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25576}
01:03:22 INFO reader-main src/vim.rs:380 <= None {"id": 25576, "jsonrpc": "2.0", "result": [12, 60]}
01:03:22 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:03:22 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:03:22 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:03:22 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 43, "LSP#visible_line_start()": 12, "LSP#visible_line_end()": 60, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:22 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:22 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:22 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43)]
01:03:22 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:03:22 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:22 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:03:22 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:22 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:03:22 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:22 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:03:22 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25577}
01:03:22 INFO reader-main src/vim.rs:380 <= None {"id": 25577, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: scientifict -> Int", "scientifictToInt num =", "  case AUtils.floatingOrInteger num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:03:22 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: scientifict -> Int"), String("scientifictToInt num ="), String("  case AUtils.floatingOrInteger num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:03:22 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifict -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |>  scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifict -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:03:22 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 627 ==> 628
01:03:22 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifict -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":628}}}
01:03:22 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:03:22 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:03:23 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[{"severity":1,"range":{"start":{"line":32,"character":32},"end":{"line":32,"character":35}},"source":"ghcmod","message":"• Couldn't match expected type ‘Data.Scientific.Scientific’\n              with actual type ‘scientifict’\n  ‘scientifict’ is a rigid type variable bound by\n    the type signature for:\n      scientifictToInt :: forall scientifict. scientifict -> Int\n    at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3762.hs:31:1-38\n• In the first argument of ‘AUtils.floatingOrInteger’, namely ‘num’\n  In the expression: AUtils.floatingOrInteger num\n  In the expression:\n    case AUtils.floatingOrInteger num of\n      Left float -> fromIntegral (round float)\n      Right integral -> fromIntegral integral\n• Relevant bindings include\n    num :: scientifict\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3762.hs:32:18)\n    scientifictToInt :: scientifict -> Int\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3762.hs:32:1)"}]},"method":"textDocument/publishDiagnostics"}
01:03:23 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":33,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":33,"nr":null,"text":"• Couldn't match expected type ‘Data.Scientific.Scientific’\n              with actual type ‘scientifict’\n  ‘scientifict’ is a rigid type variable bound by\n    the type signature for:\n      scientifictToInt :: forall scientifict. scientifict -> Int\n    at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3762.hs:31:1-38\n• In the first argument of ‘AUtils.floatingOrInteger’, namely ‘num’\n  In the expression: AUtils.floatingOrInteger num\n  In the expression:\n    case AUtils.floatingOrInteger num of\n      Left float -> fromIntegral (round float)\n      Right integral -> fromIntegral integral\n• Relevant bindings include\n    num :: scientifict\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3762.hs:32:18)\n    scientifictToInt :: scientifict -> Int\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3762.hs:32:1)","type":"E"}],"r"],"id":25578}
01:03:23 INFO reader-main src/vim.rs:380 <= None {"id": 25578, "jsonrpc": "2.0", "result": 0}
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25579}
01:03:23 INFO reader-main src/vim.rs:380 <= None {"id": 25579, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:03:23 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:23 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25580}
01:03:23 INFO reader-main src/vim.rs:380 <= None {"id": 25580, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 43]}
01:03:23 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43)]
01:03:23 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25581}
01:03:23 INFO reader-main src/vim.rs:380 <= None {"id": 25581, "jsonrpc": "2.0", "result": [12, 60]}
01:03:23 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:03:23 INFO main src/languageclient.rs:2270 Updating signs: ["sign place 75128 line=33 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"]
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"execute","params":["sign place 75128 line=33 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"],"id":25582}
01:03:23 INFO reader-main src/vim.rs:380 <= None {"id": 25582, "jsonrpc": "2.0", "result": 0}
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"nvim_buf_clear_highlight","params":[0,1,12,60]}
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:AddHighlights","params":[1,[{"character_end":35,"character_start":32,"group":"ALEError","line":32,"text":"num"}]]}
01:03:23 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:03:23 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:03:23 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 30, "LSP#visible_line_start()": 6, "LSP#visible_line_end()": 54, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:23 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:23 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(30)]
01:03:23 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(6), Number(54)]
01:03:23 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:23 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:23 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:03:23 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:23 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:03:23 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:23 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25583}
01:03:23 INFO reader-main src/vim.rs:380 <= None {"id": 25583, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: scientifictToInt -> Int", "scientifictToInt num =", "  case AUtils.floatingOrInteger num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:03:23 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: scientifictToInt -> Int"), String("scientifictToInt num ="), String("  case AUtils.floatingOrInteger num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:03:23 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifict -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifictToInt -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:03:23 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 628 ==> 629
01:03:23 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifictToInt -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":629}}}
01:03:23 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:03:23 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:03:23 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[{"severity":1,"range":{"start":{"line":32,"character":32},"end":{"line":32,"character":35}},"source":"ghcmod","message":"• Couldn't match expected type ‘Data.Scientific.Scientific’\n              with actual type ‘scientifict’\n  ‘scientifict’ is a rigid type variable bound by\n    the type signature for:\n      scientifictToInt :: forall scientifict. scientifict -> Int\n    at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3762.hs:31:1-38\n• In the first argument of ‘AUtils.floatingOrInteger’, namely ‘num’\n  In the expression: AUtils.floatingOrInteger num\n  In the expression:\n    case AUtils.floatingOrInteger num of\n      Left float -> fromIntegral (round float)\n      Right integral -> fromIntegral integral\n• Relevant bindings include\n    num :: scientifict\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3762.hs:32:18)\n    scientifictToInt :: scientifict -> Int\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3762.hs:32:1)"}]},"method":"textDocument/publishDiagnostics"}
01:03:23 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":33,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":33,"nr":null,"text":"• Couldn't match expected type ‘Data.Scientific.Scientific’\n              with actual type ‘scientifict’\n  ‘scientifict’ is a rigid type variable bound by\n    the type signature for:\n      scientifictToInt :: forall scientifict. scientifict -> Int\n    at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3762.hs:31:1-38\n• In the first argument of ‘AUtils.floatingOrInteger’, namely ‘num’\n  In the expression: AUtils.floatingOrInteger num\n  In the expression:\n    case AUtils.floatingOrInteger num of\n      Left float -> fromIntegral (round float)\n      Right integral -> fromIntegral integral\n• Relevant bindings include\n    num :: scientifict\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3762.hs:32:18)\n    scientifictToInt :: scientifict -> Int\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3762.hs:32:1)","type":"E"}],"r"],"id":25584}
01:03:23 INFO reader-main src/vim.rs:380 <= None {"id": 25584, "jsonrpc": "2.0", "result": 0}
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25585}
01:03:23 INFO reader-main src/vim.rs:380 <= None {"id": 25585, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:03:23 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:23 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25586}
01:03:23 INFO reader-main src/vim.rs:380 <= None {"id": 25586, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 30]}
01:03:23 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(30)]
01:03:23 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25587}
01:03:23 INFO reader-main src/vim.rs:380 <= None {"id": 25587, "jsonrpc": "2.0", "result": [6, 54]}
01:03:23 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(6), Number(54)]
01:03:23 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:03:23 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:03:23 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:23 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:03:23 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:23 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:03:23 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:23 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25588}
01:03:23 INFO reader-main src/vim.rs:380 <= None {"id": 25588, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt ::  -> Int", "scientifictToInt num =", "  case AUtils.floatingOrInteger num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:03:23 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt ::  -> Int"), String("scientifictToInt num ="), String("  case AUtils.floatingOrInteger num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:03:23 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: scientifictToInt -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt ::  -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:03:23 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 629 ==> 630
01:03:23 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt ::  -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":630}}}
01:03:23 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:03:23 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:03:23 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[{"severity":1,"range":{"start":{"line":32,"character":32},"end":{"line":32,"character":35}},"source":"ghcmod","message":"• Couldn't match expected type ‘Data.Scientific.Scientific’\n              with actual type ‘scientifict’\n  ‘scientifict’ is a rigid type variable bound by\n    the type signature for:\n      scientifictToInt :: forall scientifict. scientifict -> Int\n    at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3763.hs:31:1-38\n• In the first argument of ‘AUtils.floatingOrInteger’, namely ‘num’\n  In the expression: AUtils.floatingOrInteger num\n  In the expression:\n    case AUtils.floatingOrInteger num of\n      Left float -> fromIntegral (round float)\n      Right integral -> fromIntegral integral\n• Relevant bindings include\n    num :: scientifict\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3763.hs:32:18)\n    scientifictToInt :: scientifict -> Int\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3763.hs:32:1)"}]},"method":"textDocument/publishDiagnostics"}
01:03:23 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":33,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":33,"nr":null,"text":"• Couldn't match expected type ‘Data.Scientific.Scientific’\n              with actual type ‘scientifict’\n  ‘scientifict’ is a rigid type variable bound by\n    the type signature for:\n      scientifictToInt :: forall scientifict. scientifict -> Int\n    at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3763.hs:31:1-38\n• In the first argument of ‘AUtils.floatingOrInteger’, namely ‘num’\n  In the expression: AUtils.floatingOrInteger num\n  In the expression:\n    case AUtils.floatingOrInteger num of\n      Left float -> fromIntegral (round float)\n      Right integral -> fromIntegral integral\n• Relevant bindings include\n    num :: scientifict\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3763.hs:32:18)\n    scientifictToInt :: scientifict -> Int\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3763.hs:32:1)","type":"E"}],"r"],"id":25589}
01:03:23 INFO reader-main src/vim.rs:380 <= None {"id": 25589, "jsonrpc": "2.0", "result": 0}
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25590}
01:03:23 INFO reader-main src/vim.rs:380 <= None {"id": 25590, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:03:23 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:23 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25591}
01:03:23 INFO reader-main src/vim.rs:380 <= None {"id": 25591, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 30]}
01:03:23 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(30)]
01:03:23 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25592}
01:03:23 INFO reader-main src/vim.rs:380 <= None {"id": 25592, "jsonrpc": "2.0", "result": [6, 54]}
01:03:23 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(6), Number(54)]
01:03:23 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:03:23 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:03:23 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[{"severity":3,"range":{"start":{"line":30,"character":21},"end":{"line":30,"character":100000}},"code":"parser","source":"hlint","message":"Parse error: ->\n  jsonrpcDecoder v = v .: \"jsonrpc\"\n  \n> scientifictToInt ::  -> Int\n  scientifictToInt num =\n    case AUtils.floatingOrInteger num of\n\n"},{"severity":1,"range":{"start":{"line":32,"character":32},"end":{"line":32,"character":35}},"source":"ghcmod","message":"• Couldn't match expected type ‘Data.Scientific.Scientific’\n              with actual type ‘scientifict’\n  ‘scientifict’ is a rigid type variable bound by\n    the type signature for:\n      scientifictToInt :: forall scientifict. scientifict -> Int\n    at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3763.hs:31:1-38\n• In the first argument of ‘AUtils.floatingOrInteger’, namely ‘num’\n  In the expression: AUtils.floatingOrInteger num\n  In the expression:\n    case AUtils.floatingOrInteger num of\n      Left float -> fromIntegral (round float)\n      Right integral -> fromIntegral integral\n• Relevant bindings include\n    num :: scientifict\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3763.hs:32:18)\n    scientifictToInt :: scientifict -> Int\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3763.hs:32:1)"}]},"method":"textDocument/publishDiagnostics"}
01:03:23 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":22,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":31,"nr":"parser","text":"Parse error: ->\n  jsonrpcDecoder v = v .: \"jsonrpc\"\n  \n> scientifictToInt ::  -> Int\n  scientifictToInt num =\n    case AUtils.floatingOrInteger num of\n\n","type":"I"},{"col":33,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":33,"nr":null,"text":"• Couldn't match expected type ‘Data.Scientific.Scientific’\n              with actual type ‘scientifict’\n  ‘scientifict’ is a rigid type variable bound by\n    the type signature for:\n      scientifictToInt :: forall scientifict. scientifict -> Int\n    at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3763.hs:31:1-38\n• In the first argument of ‘AUtils.floatingOrInteger’, namely ‘num’\n  In the expression: AUtils.floatingOrInteger num\n  In the expression:\n    case AUtils.floatingOrInteger num of\n      Left float -> fromIntegral (round float)\n      Right integral -> fromIntegral integral\n• Relevant bindings include\n    num :: scientifict\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3763.hs:32:18)\n    scientifictToInt :: scientifict -> Int\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3763.hs:32:1)","type":"E"}],"r"],"id":25593}
01:03:23 INFO reader-main src/vim.rs:380 <= None {"id": 25593, "jsonrpc": "2.0", "result": 0}
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25594}
01:03:23 INFO reader-main src/vim.rs:380 <= None {"id": 25594, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:03:23 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:23 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25595}
01:03:23 INFO reader-main src/vim.rs:380 <= None {"id": 25595, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 30]}
01:03:23 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(30)]
01:03:23 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25596}
01:03:23 INFO reader-main src/vim.rs:380 <= None {"id": 25596, "jsonrpc": "2.0", "result": [6, 54]}
01:03:23 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(6), Number(54)]
01:03:23 INFO main src/languageclient.rs:2270 Updating signs: ["sign place 75122 line=31 name=LanguageClientInformation file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"]
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"execute","params":["sign place 75122 line=31 name=LanguageClientInformation file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"],"id":25597}
01:03:23 INFO reader-main src/vim.rs:380 <= None {"id": 25597, "jsonrpc": "2.0", "result": 0}
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"nvim_buf_clear_highlight","params":[0,1,6,54]}
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:AddHighlights","params":[1,[{"character_end":100000,"character_start":21,"group":"ALEInfo","line":30,"text":""},{"character_end":35,"character_start":32,"group":"ALEError","line":32,"text":"num"}]]}
01:03:23 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:03:23 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:03:23 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:23 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:03:23 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:23 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:03:23 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:23 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:03:23 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25598}
01:03:23 INFO reader-main src/vim.rs:380 <= None {"id": 25598, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case AUtils.floatingOrInteger num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:03:23 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case AUtils.floatingOrInteger num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:03:23 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt ::  -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:03:23 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 630 ==> 631
01:03:23 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":631}}}
01:03:23 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:03:23 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:03:24 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[{"severity":1,"range":{"start":{"line":30,"character":21},"end":{"line":30,"character":23}},"source":"ghcmod","message":"parse error on input ‘->’"}]},"method":"textDocument/publishDiagnostics"}
01:03:24 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":22,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":31,"nr":null,"text":"parse error on input ‘->’","type":"E"}],"r"],"id":25599}
01:03:24 INFO reader-main src/vim.rs:380 <= None {"id": 25599, "jsonrpc": "2.0", "result": 0}
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25600}
01:03:24 INFO reader-main src/vim.rs:380 <= None {"id": 25600, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:03:24 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:24 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25601}
01:03:24 INFO reader-main src/vim.rs:380 <= None {"id": 25601, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 30]}
01:03:24 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(30)]
01:03:24 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25602}
01:03:24 INFO reader-main src/vim.rs:380 <= None {"id": 25602, "jsonrpc": "2.0", "result": [6, 54]}
01:03:24 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(6), Number(54)]
01:03:24 INFO main src/languageclient.rs:2270 Updating signs: ["sign unplace 75122 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", "sign unplace 75128 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", "sign place 75120 line=31 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"]
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"execute","params":["sign unplace 75122 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","sign unplace 75128 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","sign place 75120 line=31 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"],"id":25603}
01:03:24 INFO reader-main src/vim.rs:380 <= None {"id": 25603, "jsonrpc": "2.0", "result": 0}
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"nvim_buf_clear_highlight","params":[0,1,6,54]}
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:AddHighlights","params":[1,[{"character_end":23,"character_start":21,"group":"ALEError","line":30,"text":"Re"}]]}
01:03:24 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:03:24 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:03:24 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[{"severity":1,"range":{"start":{"line":30,"character":21},"end":{"line":30,"character":23}},"source":"ghcmod","message":"parse error on input ‘->’"}]},"method":"textDocument/publishDiagnostics"}
01:03:24 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":22,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":31,"nr":null,"text":"parse error on input ‘->’","type":"E"}],"r"],"id":25604}
01:03:24 INFO reader-main src/vim.rs:380 <= None {"id": 25604, "jsonrpc": "2.0", "result": 0}
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25605}
01:03:24 INFO reader-main src/vim.rs:380 <= None {"id": 25605, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:03:24 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:24 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25606}
01:03:24 INFO reader-main src/vim.rs:380 <= None {"id": 25606, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 30]}
01:03:24 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(30)]
01:03:24 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25607}
01:03:24 INFO reader-main src/vim.rs:380 <= None {"id": 25607, "jsonrpc": "2.0", "result": [6, 54]}
01:03:24 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(6), Number(54)]
01:03:24 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:03:24 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:03:24 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 32, "LSP#visible_line_start()": 8, "LSP#visible_line_end()": 56, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:24 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:24 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(32)]
01:03:24 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(8), Number(56)]
01:03:24 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:24 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:24 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:03:24 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:24 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:03:24 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:24 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25608}
01:03:24 INFO reader-main src/vim.rs:380 <= None {"id": 25608, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case AUtils.floatingOrInteger of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:03:24 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case AUtils.floatingOrInteger of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:03:24 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 631 ==> 632
01:03:24 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:03:24 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":632}}}
01:03:24 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:03:24 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:03:24 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[{"severity":1,"range":{"start":{"line":32,"character":32},"end":{"line":32,"character":35}},"source":"ghcmod","message":"• Couldn't match expected type ‘Data.Scientific.Scientific’\n              with actual type ‘Either r i’\n• In the first argument of ‘AUtils.floatingOrInteger’, namely ‘num’\n  In the expression: AUtils.floatingOrInteger num\n  In the expression:\n    case AUtils.floatingOrInteger num of\n      Left float -> fromIntegral (round float)\n      Right integral -> fromIntegral integral\n• Relevant bindings include\n    num :: Either r i\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3766.hs:32:18)\n    scientifictToInt :: Either r i -> Int\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3766.hs:32:1)"}]},"method":"textDocument/publishDiagnostics"}
01:03:24 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":33,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":33,"nr":null,"text":"• Couldn't match expected type ‘Data.Scientific.Scientific’\n              with actual type ‘Either r i’\n• In the first argument of ‘AUtils.floatingOrInteger’, namely ‘num’\n  In the expression: AUtils.floatingOrInteger num\n  In the expression:\n    case AUtils.floatingOrInteger num of\n      Left float -> fromIntegral (round float)\n      Right integral -> fromIntegral integral\n• Relevant bindings include\n    num :: Either r i\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3766.hs:32:18)\n    scientifictToInt :: Either r i -> Int\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3766.hs:32:1)","type":"E"}],"r"],"id":25609}
01:03:24 INFO reader-main src/vim.rs:380 <= None {"id": 25609, "jsonrpc": "2.0", "result": 0}
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25610}
01:03:24 INFO reader-main src/vim.rs:380 <= None {"id": 25610, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:03:24 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:24 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25611}
01:03:24 INFO reader-main src/vim.rs:380 <= None {"id": 25611, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 32]}
01:03:24 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(32)]
01:03:24 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25612}
01:03:24 INFO reader-main src/vim.rs:380 <= None {"id": 25612, "jsonrpc": "2.0", "result": [8, 56]}
01:03:24 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(8), Number(56)]
01:03:24 INFO main src/languageclient.rs:2270 Updating signs: ["sign unplace 75120 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", "sign place 75128 line=33 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"]
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"execute","params":["sign unplace 75120 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","sign place 75128 line=33 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"],"id":25613}
01:03:24 INFO reader-main src/vim.rs:380 <= None {"id": 25613, "jsonrpc": "2.0", "result": 0}
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"nvim_buf_clear_highlight","params":[0,1,8,56]}
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:AddHighlights","params":[1,[{"character_end":35,"character_start":32,"group":"ALEError","line":32,"text":""}]]}
01:03:24 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:03:24 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:03:24 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[{"severity":1,"range":{"start":{"line":32,"character":32},"end":{"line":32,"character":35}},"source":"ghcmod","message":"• Couldn't match expected type ‘Data.Scientific.Scientific’\n              with actual type ‘Either r i’\n• In the first argument of ‘AUtils.floatingOrInteger’, namely ‘num’\n  In the expression: AUtils.floatingOrInteger num\n  In the expression:\n    case AUtils.floatingOrInteger num of\n      Left float -> fromIntegral (round float)\n      Right integral -> fromIntegral integral\n• Relevant bindings include\n    num :: Either r i\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3766.hs:32:18)\n    scientifictToInt :: Either r i -> Int\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3766.hs:32:1)"}]},"method":"textDocument/publishDiagnostics"}
01:03:24 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":33,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":33,"nr":null,"text":"• Couldn't match expected type ‘Data.Scientific.Scientific’\n              with actual type ‘Either r i’\n• In the first argument of ‘AUtils.floatingOrInteger’, namely ‘num’\n  In the expression: AUtils.floatingOrInteger num\n  In the expression:\n    case AUtils.floatingOrInteger num of\n      Left float -> fromIntegral (round float)\n      Right integral -> fromIntegral integral\n• Relevant bindings include\n    num :: Either r i\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3766.hs:32:18)\n    scientifictToInt :: Either r i -> Int\n      (bound at /private/var/folders/qj/vf9pxy3d43sf4jl9ygx71kx00000gn/T/ghc-mod9817/IncomingMessage9816-3766.hs:32:1)","type":"E"}],"r"],"id":25614}
01:03:24 INFO reader-main src/vim.rs:380 <= None {"id": 25614, "jsonrpc": "2.0", "result": 0}
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25615}
01:03:24 INFO reader-main src/vim.rs:380 <= None {"id": 25615, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:03:24 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:24 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25616}
01:03:24 INFO reader-main src/vim.rs:380 <= None {"id": 25616, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 32]}
01:03:24 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(32)]
01:03:24 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25617}
01:03:24 INFO reader-main src/vim.rs:380 <= None {"id": 25617, "jsonrpc": "2.0", "result": [8, 56]}
01:03:24 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(8), Number(56)]
01:03:24 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:03:24 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:03:24 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:24 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:03:24 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:24 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:03:24 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:24 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:03:24 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25618}
01:03:24 INFO reader-main src/vim.rs:380 <= None {"id": 25618, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:03:24 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:03:24 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 632 ==> 633
01:03:24 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case AUtils.floatingOrInteger of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:03:24 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":633}}}
01:03:24 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:03:24 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:03:25 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[{"severity":1,"range":{"start":{"line":33,"character":4},"end":{"line":33,"character":14}},"source":"ghcmod","message":"• Couldn't match expected type ‘Data.Scientific.Scientific\n                                -> Either Double Integer’\n              with actual type ‘Either Double b0’\n• In the pattern: Left float\n  In a case alternative: Left float -> fromIntegral (round float)\n  In the expression:\n    case AUtils.floatingOrInteger of\n      Left float -> fromIntegral (round float)\n      Right integral -> fromIntegral integral"},{"severity":1,"range":{"start":{"line":34,"character":4},"end":{"line":34,"character":18}},"source":"ghcmod","message":"• Couldn't match expected type ‘Data.Scientific.Scientific\n                                -> Either Double Integer’\n              with actual type ‘Either a0 Integer’\n• In the pattern: Right integral\n  In a case alternative: Right integral -> fromIntegral integral\n  In the expression:\n    case AUtils.floatingOrInteger of\n      Left float -> fromIntegral (round float)\n      Right integral -> fromIntegral integral"}]},"method":"textDocument/publishDiagnostics"}
01:03:25 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":5,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":34,"nr":null,"text":"• Couldn't match expected type ‘Data.Scientific.Scientific\n                                -> Either Double Integer’\n              with actual type ‘Either Double b0’\n• In the pattern: Left float\n  In a case alternative: Left float -> fromIntegral (round float)\n  In the expression:\n    case AUtils.floatingOrInteger of\n      Left float -> fromIntegral (round float)\n      Right integral -> fromIntegral integral","type":"E"},{"col":5,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":35,"nr":null,"text":"• Couldn't match expected type ‘Data.Scientific.Scientific\n                                -> Either Double Integer’\n              with actual type ‘Either a0 Integer’\n• In the pattern: Right integral\n  In a case alternative: Right integral -> fromIntegral integral\n  In the expression:\n    case AUtils.floatingOrInteger of\n      Left float -> fromIntegral (round float)\n      Right integral -> fromIntegral integral","type":"E"}],"r"],"id":25619}
01:03:25 INFO reader-main src/vim.rs:380 <= None {"id": 25619, "jsonrpc": "2.0", "result": 0}
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25620}
01:03:25 INFO reader-main src/vim.rs:380 <= None {"id": 25620, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:03:25 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:25 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25621}
01:03:25 INFO reader-main src/vim.rs:380 <= None {"id": 25621, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 32]}
01:03:25 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(32)]
01:03:25 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25622}
01:03:25 INFO reader-main src/vim.rs:380 <= None {"id": 25622, "jsonrpc": "2.0", "result": [8, 56]}
01:03:25 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(8), Number(56)]
01:03:25 INFO main src/languageclient.rs:2270 Updating signs: ["sign unplace 75128 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", "sign place 75132 line=34 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", "sign place 75136 line=35 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"]
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"execute","params":["sign unplace 75128 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","sign place 75132 line=34 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","sign place 75136 line=35 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"],"id":25623}
01:03:25 INFO reader-main src/vim.rs:380 <= None {"id": 25623, "jsonrpc": "2.0", "result": 0}
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"nvim_buf_clear_highlight","params":[0,1,8,56]}
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:AddHighlights","params":[1,[{"character_end":14,"character_start":4,"group":"ALEError","line":33,"text":"Left float"},{"character_end":18,"character_start":4,"group":"ALEError","line":34,"text":"Right integral"}]]}
01:03:25 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:03:25 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:03:25 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[{"severity":1,"range":{"start":{"line":33,"character":4},"end":{"line":33,"character":14}},"source":"ghcmod","message":"• Couldn't match expected type ‘Data.Scientific.Scientific\n                                -> Either Double Integer’\n              with actual type ‘Either Double b0’\n• In the pattern: Left float\n  In a case alternative: Left float -> fromIntegral (round float)\n  In the expression:\n    case AUtils.floatingOrInteger of\n      Left float -> fromIntegral (round float)\n      Right integral -> fromIntegral integral"},{"severity":1,"range":{"start":{"line":34,"character":4},"end":{"line":34,"character":18}},"source":"ghcmod","message":"• Couldn't match expected type ‘Data.Scientific.Scientific\n                                -> Either Double Integer’\n              with actual type ‘Either a0 Integer’\n• In the pattern: Right integral\n  In a case alternative: Right integral -> fromIntegral integral\n  In the expression:\n    case AUtils.floatingOrInteger of\n      Left float -> fromIntegral (round float)\n      Right integral -> fromIntegral integral"}]},"method":"textDocument/publishDiagnostics"}
01:03:25 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":5,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":34,"nr":null,"text":"• Couldn't match expected type ‘Data.Scientific.Scientific\n                                -> Either Double Integer’\n              with actual type ‘Either Double b0’\n• In the pattern: Left float\n  In a case alternative: Left float -> fromIntegral (round float)\n  In the expression:\n    case AUtils.floatingOrInteger of\n      Left float -> fromIntegral (round float)\n      Right integral -> fromIntegral integral","type":"E"},{"col":5,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":35,"nr":null,"text":"• Couldn't match expected type ‘Data.Scientific.Scientific\n                                -> Either Double Integer’\n              with actual type ‘Either a0 Integer’\n• In the pattern: Right integral\n  In a case alternative: Right integral -> fromIntegral integral\n  In the expression:\n    case AUtils.floatingOrInteger of\n      Left float -> fromIntegral (round float)\n      Right integral -> fromIntegral integral","type":"E"}],"r"],"id":25624}
01:03:25 INFO reader-main src/vim.rs:380 <= None {"id": 25624, "jsonrpc": "2.0", "result": 0}
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25625}
01:03:25 INFO reader-main src/vim.rs:380 <= None {"id": 25625, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:03:25 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:25 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25626}
01:03:25 INFO reader-main src/vim.rs:380 <= None {"id": 25626, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 32]}
01:03:25 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(32)]
01:03:25 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25627}
01:03:25 INFO reader-main src/vim.rs:380 <= None {"id": 25627, "jsonrpc": "2.0", "result": [8, 56]}
01:03:25 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(8), Number(56)]
01:03:25 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:03:25 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:03:25 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 43, "LSP#visible_line_start()": 11, "LSP#visible_line_end()": 59, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:25 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:25 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43)]
01:03:25 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(11), Number(59)]
01:03:25 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:25 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:25 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:03:25 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:25 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:03:25 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:25 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25628}
01:03:25 INFO reader-main src/vim.rs:380 <= None {"id": 25628, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |> T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:03:25 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |> T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:03:25 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:03:25 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 633 ==> 634
01:03:25 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":634}}}
01:03:25 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:03:25 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:03:25 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[]},"method":"textDocument/publishDiagnostics"}
01:03:25 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[],"r"],"id":25629}
01:03:25 INFO reader-main src/vim.rs:380 <= None {"id": 25629, "jsonrpc": "2.0", "result": 0}
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25630}
01:03:25 INFO reader-main src/vim.rs:380 <= None {"id": 25630, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:03:25 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:25 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25631}
01:03:25 INFO reader-main src/vim.rs:380 <= None {"id": 25631, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 43]}
01:03:25 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43)]
01:03:25 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25632}
01:03:25 INFO reader-main src/vim.rs:380 <= None {"id": 25632, "jsonrpc": "2.0", "result": [11, 59]}
01:03:25 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(11), Number(59)]
01:03:25 INFO main src/languageclient.rs:2270 Updating signs: ["sign unplace 75132 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", "sign unplace 75136 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"]
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"execute","params":["sign unplace 75132 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","sign unplace 75136 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"],"id":25633}
01:03:25 INFO reader-main src/vim.rs:380 <= None {"id": 25633, "jsonrpc": "2.0", "result": 0}
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"nvim_buf_clear_highlight","params":[0,1,11,59]}
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:AddHighlights","params":[1,[]]}
01:03:25 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:03:25 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:03:25 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[]},"method":"textDocument/publishDiagnostics"}
01:03:25 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[],"r"],"id":25634}
01:03:25 INFO reader-main src/vim.rs:380 <= None {"id": 25634, "jsonrpc": "2.0", "result": 0}
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25635}
01:03:25 INFO reader-main src/vim.rs:380 <= None {"id": 25635, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:03:25 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:25 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25636}
01:03:25 INFO reader-main src/vim.rs:380 <= None {"id": 25636, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 43]}
01:03:25 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43)]
01:03:25 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25637}
01:03:25 INFO reader-main src/vim.rs:380 <= None {"id": 25637, "jsonrpc": "2.0", "result": [11, 59]}
01:03:25 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(11), Number(59)]
01:03:25 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:25 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:03:25 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:03:26 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[]},"method":"textDocument/publishDiagnostics"}
01:03:26 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:03:26 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[],"r"],"id":25638}
01:03:26 INFO reader-main src/vim.rs:380 <= None {"id": 25638, "jsonrpc": "2.0", "result": 0}
01:03:26 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25639}
01:03:26 INFO reader-main src/vim.rs:380 <= None {"id": 25639, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:03:26 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:26 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:03:26 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25640}
01:03:26 INFO reader-main src/vim.rs:380 <= None {"id": 25640, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 43]}
01:03:26 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43)]
01:03:26 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:03:26 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25641}
01:03:26 INFO reader-main src/vim.rs:380 <= None {"id": 25641, "jsonrpc": "2.0", "result": [11, 59]}
01:03:26 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(11), Number(59)]
01:03:26 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:26 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:03:26 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:03:26 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:26 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:03:26 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:26 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:03:26 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:26 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:03:26 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25642}
01:03:26 INFO reader-main src/vim.rs:380 <= None {"id": 25642, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils. |> scientifictToInt |> show |> T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:03:26 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils. |> scientifictToInt |> show |> T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:03:26 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 634 ==> 635
01:03:26 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils. |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:03:26 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils. |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":635}}}
01:03:26 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:03:26 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:03:27 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:27 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:03:27 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:27 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:03:27 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:27 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:03:27 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25643}
01:03:27 INFO reader-main src/vim.rs:380 <= None {"id": 25643, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.fromFloatDigits |> scientifictToInt |> show |> T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:03:27 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.fromFloatDigits |> scientifictToInt |> show |> T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:03:27 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 635 ==> 636
01:03:27 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils. |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.fromFloatDigits |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:03:27 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.fromFloatDigits |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":636}}}
01:03:27 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:03:27 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:03:27 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:27 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:03:27 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:27 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:03:27 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:27 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:03:27 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25644}
01:03:27 INFO reader-main src/vim.rs:380 <= None {"id": 25644, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils. |> scientifictToInt |> show |> T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:03:27 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils. |> scientifictToInt |> show |> T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:03:27 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.fromFloatDigits |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils. |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:03:27 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 636 ==> 637
01:03:27 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils. |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":637}}}
01:03:27 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:03:27 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:03:27 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:27 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:03:27 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:27 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:03:27 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:27 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:03:27 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25645}
01:03:27 INFO reader-main src/vim.rs:380 <= None {"id": 25645, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |> T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:03:27 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |> T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:03:27 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 637 ==> 638
01:03:27 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils. |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:03:27 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":638}}}
01:03:27 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:03:27 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:03:28 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleBufWritePost", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:28 INFO main src/languageclient.rs:2199 Begin languageClient/handleBufWritePost
01:03:28 INFO main src/languageclient.rs:1826 Begin textDocument/didSave
01:03:28 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:28 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}}
01:03:28 INFO main src/languageclient.rs:1844 End textDocument/didSave
01:03:28 INFO main src/languageclient.rs:2201 End languageClient/handleBufWritePost
01:03:28 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[]},"method":"textDocument/publishDiagnostics"}
01:03:28 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:03:28 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[],"r"],"id":25646}
01:03:28 INFO reader-main src/vim.rs:380 <= None {"id": 25646, "jsonrpc": "2.0", "result": 0}
01:03:28 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25647}
01:03:28 INFO reader-main src/vim.rs:380 <= None {"id": 25647, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:03:28 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:28 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:03:28 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25648}
01:03:28 INFO reader-main src/vim.rs:380 <= None {"id": 25648, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 43]}
01:03:28 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43)]
01:03:28 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:03:28 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25649}
01:03:28 INFO reader-main src/vim.rs:380 <= None {"id": 25649, "jsonrpc": "2.0", "result": [11, 59]}
01:03:28 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(11), Number(59)]
01:03:28 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:28 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:03:28 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:03:28 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:28 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:03:28 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:28 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:03:28 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:28 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:03:28 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25650}
01:03:28 INFO reader-main src/vim.rs:380 <= None {"id": 25650, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:03:28 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:03:28 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 638 ==> 639
01:03:28 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:03:28 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":639}}}
01:03:28 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:03:28 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:03:28 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[]},"method":"textDocument/publishDiagnostics"}
01:03:28 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:03:28 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[],"r"],"id":25651}
01:03:28 INFO reader-main src/vim.rs:380 <= None {"id": 25651, "jsonrpc": "2.0", "result": 0}
01:03:28 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25652}
01:03:28 INFO reader-main src/vim.rs:380 <= None {"id": 25652, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:03:28 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[]},"method":"textDocument/publishDiagnostics"}
01:03:28 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:28 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:03:28 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25653}
01:03:28 INFO reader-main src/vim.rs:380 <= None {"id": 25653, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 43]}
01:03:28 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43)]
01:03:28 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:03:28 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25654}
01:03:28 INFO reader-main src/vim.rs:380 <= None {"id": 25654, "jsonrpc": "2.0", "result": [12, 60]}
01:03:28 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:03:28 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:28 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:03:28 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:03:28 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:03:28 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[],"r"],"id":25655}
01:03:28 INFO reader-main src/vim.rs:380 <= None {"id": 25655, "jsonrpc": "2.0", "result": 0}
01:03:28 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25656}
01:03:28 INFO reader-main src/vim.rs:380 <= None {"id": 25656, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:03:28 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:28 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:03:28 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25657}
01:03:28 INFO reader-main src/vim.rs:380 <= None {"id": 25657, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 43]}
01:03:28 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43)]
01:03:28 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:03:28 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25658}
01:03:28 INFO reader-main src/vim.rs:380 <= None {"id": 25658, "jsonrpc": "2.0", "result": [12, 60]}
01:03:28 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:03:28 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:28 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:03:28 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:03:28 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[]},"method":"textDocument/publishDiagnostics"}
01:03:28 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:03:28 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[],"r"],"id":25659}
01:03:28 INFO reader-main src/vim.rs:380 <= None {"id": 25659, "jsonrpc": "2.0", "result": 0}
01:03:28 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25660}
01:03:28 INFO reader-main src/vim.rs:380 <= None {"id": 25660, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:03:28 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:28 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:03:28 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25661}
01:03:28 INFO reader-main src/vim.rs:380 <= None {"id": 25661, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 43]}
01:03:28 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43)]
01:03:28 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:03:28 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25662}
01:03:28 INFO reader-main src/vim.rs:380 <= None {"id": 25662, "jsonrpc": "2.0", "result": [12, 60]}
01:03:28 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:03:28 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:28 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:03:28 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:03:29 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[]},"method":"textDocument/publishDiagnostics"}
01:03:29 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:03:29 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[],"r"],"id":25663}
01:03:29 INFO reader-main src/vim.rs:380 <= None {"id": 25663, "jsonrpc": "2.0", "result": 0}
01:03:29 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25664}
01:03:29 INFO reader-main src/vim.rs:380 <= None {"id": 25664, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:03:29 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:29 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:03:29 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25665}
01:03:29 INFO reader-main src/vim.rs:380 <= None {"id": 25665, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 43]}
01:03:29 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43)]
01:03:29 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:03:29 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25666}
01:03:29 INFO reader-main src/vim.rs:380 <= None {"id": 25666, "jsonrpc": "2.0", "result": [12, 60]}
01:03:29 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:03:29 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:03:29 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:03:29 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:03:31 INFO reader-main src/vim.rs:380 <= None {"id": 767, "jsonrpc": "2.0", "method": "LanguageClient_NCM2OnComplete", "params": {"languageId": "haskell", "ctx": {"filepath": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", "typed": "           (num |> AUtils.f", "scope_match": "haskell", "startccol": 27, "scope_level": 1, "word_pattern": "(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)", "time": 1.535782e9, "lnum": 44, "bufnr": 1, "changedtick": 4164, "manual": 0, "base": "f", "ccol": 28, "filetype": "haskell", "curpos": [0, 44, 28, 0, 28], "tick": [[0, 44, 28], 80], "early_cache": false, "context_id": 6916, "scope": "haskell", "matcher": {"name": "abbrfuzzy"}, "source": {"on_complete": "LanguageClient_NCM2OnComplete", "subscope_enable": 0, "early_cache": 0, "priority": 9, "scope": ["haskell"], "mark": "LC", "ready": 1, "enable": 1, "complete_pattern": ["\\."], "auto_popup": 1, "name": "LanguageClient_haskell"}, "bcol": 28, "match_end": 26}, "buftype": ""}}
01:03:31 INFO main src/languageclient.rs:2495 Begin LanguageClient_NCM2OnComplete
01:03:31 INFO main src/languageclient.rs:1296 Begin textDocument/completion
01:03:31 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename, Line, Character, Handle] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43), Number(27), Bool(false)]
01:03:31 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/completion","params":{"position":{"character":27,"line":43},"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}},"id":25667}
01:03:31 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"result":[{"kind":3,"data":"decodeFileStrict module:Data.Aeson.Utils is:exact","label":"decodeFileStrict","detail":"forall a. FromJSON a => FilePath -> IO (Maybe a)\nData.Aeson.Utils"},{"kind":3,"data":"decodeFileStrict' module:Data.Aeson.Utils is:exact","label":"decodeFileStrict'","detail":"forall a. FromJSON a => FilePath -> IO (Maybe a)\nData.Aeson.Utils"},{"kind":3,"data":"eitherDecodeFileStrict module:Data.Aeson.Utils is:exact","label":"eitherDecodeFileStrict","detail":"forall a. FromJSON a => FilePath -> IO (Either String a)\nData.Aeson.Utils"},{"kind":3,"data":"eitherDecodeFileStrict' module:Data.Aeson.Utils is:exact","label":"eitherDecodeFileStrict'","detail":"forall a. FromJSON a => FilePath -> IO (Either String a)\nData.Aeson.Utils"},{"kind":3,"data":"encodeFile module:Data.Aeson.Utils is:exact","label":"encodeFile","detail":"forall a. ToJSON a => FilePath -> a -> IO ()\nData.Aeson.Utils"},{"kind":3,"data":"unsafeToEncoding module:Data.Aeson.Utils is:exact","label":"unsafeToEncoding","detail":"forall a. Builder -> Encoding' a\nData.Aeson.Utils"},{"kind":3,"data":"foldable module:Data.Aeson.Utils is:exact","label":"foldable","detail":"forall (t :: * -> *) a. (Foldable t, ToJSON a) => t a -> Encoding\nData.Aeson.Utils"},{"kind":3,"data":"coerceFromJSONKeyFunction module:Data.Aeson.Utils is:exact","label":"coerceFromJSONKeyFunction","detail":"forall a b.\nCoercible a b =>\nFromJSONKeyFunction a -> FromJSONKeyFunction b\nData.Aeson.Utils"},{"kind":3,"data":"explicitParseField module:Data.Aeson.Utils is:exact","label":"explicitParseField","detail":"forall a. (Value -> Parser a) -> Object -> Text -> Parser a\nData.Aeson.Utils"},{"kind":3,"data":"explicitParseFieldMaybe module:Data.Aeson.Utils is:exact","label":"explicitParseFieldMaybe","detail":"forall a. (Value -> Parser a) -> Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils"},{"kind":3,"data":"explicitParseFieldMaybe' module:Data.Aeson.Utils is:exact","label":"explicitParseFieldMaybe'","detail":"forall a. (Value -> Parser a) -> Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils"},{"kind":3,"data":"fromJSON module:Data.Aeson.Utils is:exact","label":"fromJSON","detail":"forall a. FromJSON a => Value -> Result a\nData.Aeson.Utils"},{"kind":3,"data":"fromJSONKeyCoerce module:Data.Aeson.Utils is:exact","label":"fromJSONKeyCoerce","detail":"forall a. Coercible Text a => FromJSONKeyFunction a\nData.Aeson.Utils"},{"kind":3,"data":"genericLiftParseJSON module:Data.Aeson.Utils is:exact","label":"genericLiftParseJSON","detail":"forall (f :: * -> *) a.\n(Generic1 f, GFromJSON One (Rep1 f)) =>\nOptions\n-> (Value -> Parser a)\n-> (Value -> Parser [a])\n-> Value\n-> Parser (f a)\nData.Aeson.Utils"},{"kind":3,"data":"mapFromJSONKeyFunction module:Data.Aeson.Utils is:exact","label":"mapFromJSONKeyFunction","detail":"forall a b.\n(a -> b) -> FromJSONKeyFunction a -> FromJSONKeyFunction b\nData.Aeson.Utils"},{"kind":3,"data":"parseField module:Data.Aeson.Utils is:exact","label":"parseField","detail":"forall a. FromJSON a => Object -> Text -> Parser a\nData.Aeson.Utils"},{"kind":3,"data":"parseFieldMaybe module:Data.Aeson.Utils is:exact","label":"parseFieldMaybe","detail":"forall a. FromJSON a => Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils"},{"kind":3,"data":"parseFieldMaybe' module:Data.Aeson.Utils is:exact","label":"parseFieldMaybe'","detail":"forall a. FromJSON a => Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils"},{"kind":3,"data":"withScientific module:Data.Aeson.Utils is:exact","label":"withScientific","detail":"forall a. String -> (Scientific -> Parser a) -> Value -> Parser a\nData.Aeson.Utils"},{"kind":3,"data":"defaultOptions module:Data.Aeson.Utils is:exact","label":"defaultOptions","detail":"Options\nData.Aeson.Utils"},{"kind":3,"data":"defaultTaggedObject module:Data.Aeson.Utils is:exact","label":"defaultTaggedObject","detail":"SumEncoding\nData.Aeson.Utils"},{"kind":3,"data":"modifyFailure module:Data.Aeson.Utils is:exact","label":"modifyFailure","detail":"forall a. (String -> String) -> Parser a -> Parser a\nData.Aeson.Utils"},{"kind":3,"data":"contramapToJSONKeyFunction module:Data.Aeson.Utils is:exact","label":"contramapToJSONKeyFunction","detail":"forall b a. (b -> a) -> ToJSONKeyFunction a -> ToJSONKeyFunction b\nData.Aeson.Utils"},{"kind":3,"data":"genericLiftToEncoding module:Data.Aeson.Utils is:exact","label":"genericLiftToEncoding","detail":"forall (f :: * -> *) a.\n(Generic1 f, GToJSON Encoding One (Rep1 f)) =>\nOptions -> (a -> Encoding) -> ([a] -> Encoding) -> f a -> Encoding\nData.Aeson.Utils"},{"kind":3,"data":"genericLiftToJSON module:Data.Aeson.Utils is:exact","label":"genericLiftToJSON","detail":"forall (f :: * -> *) a.\n(Generic1 f, GToJSON Value One (Rep1 f)) =>\nOptions -> (a -> Value) -> ([a] -> Value) -> f a -> Value\nData.Aeson.Utils"},{"kind":3,"data":"floatingOrInteger module:Data.Aeson.Utils is:exact","label":"floatingOrInteger","detail":"forall r i. (RealFloat r, Integral i) => Scientific -> Either r i\nData.Aeson.Utils"},{"kind":3,"data":"fromFloatDigits module:Data.Aeson.Utils is:exact","label":"fromFloatDigits","detail":"forall a. RealFloat a => a -> Scientific\nData.Aeson.Utils"},{"kind":3,"data":"fromEncoding module:Data.Aeson.Utils is:exact","label":"fromEncoding","detail":"forall tag. Encoding' tag -> Builder\nData.Aeson.Utils"},{"kind":7,"data":"FromArgs module:Data.Aeson.Utils is:exact","label":"FromArgs","detail":"Data.Aeson.Utils"},{"kind":4,"data":"From1Args module:Data.Aeson.Utils is:exact","label":"From1Args","detail":"forall a.\n(Value -> Parser a) -> (Value -> Parser [a]) -> FromArgs One a\nData.Aeson.Utils"},{"kind":4,"data":"NoFromArgs module:Data.Aeson.Utils is:exact","label":"NoFromArgs","detail":"forall a. FromArgs Zero a\nData.Aeson.Utils"},{"kind":7,"data":"FromJSON module:Data.Aeson.Utils is:exact","label":"FromJSON","detail":"Data.Aeson.Utils"},{"kind":7,"data":"FromJSON1 module:Data.Aeson.Utils is:exact","label":"FromJSON1","detail":"Data.Aeson.Utils"},{"kind":3,"data":"liftParseJSON module:Data.Aeson.Utils is:exact","label":"liftParseJSON","detail":"forall (f :: * -> *).\nFromJSON1 f =>\nforall a.\n(Value -> Parser a)\n-> (Value -> Parser [a]) -> Value -> Parser (f a)\nData.Aeson.Utils"},{"kind":3,"data":"liftParseJSONList module:Data.Aeson.Utils is:exact","label":"liftParseJSONList","detail":"forall (f :: * -> *).\nFromJSON1 f =>\nforall a.\n(Value -> Parser a)\n-> (Value -> Parser [a]) -> Value -> Parser [f a]\nData.Aeson.Utils"},{"kind":7,"data":"FromJSON2 module:Data.Aeson.Utils is:exact","label":"FromJSON2","detail":"Data.Aeson.Utils"},{"kind":3,"data":"liftParseJSON2 module:Data.Aeson.Utils is:exact","label":"liftParseJSON2","detail":"forall (f :: * -> * -> *).\nFromJSON2 f =>\nforall a b.\n(Value -> Parser a)\n-> (Value -> Parser [a])\n-> (Value -> Parser b)\n-> (Value -> Parser [b])\n-> Value\n-> Parser (f a b)\nData.Aeson.Utils"},{"kind":3,"data":"liftParseJSONList2 module:Data.Aeson.Utils is:exact","label":"liftParseJSONList2","detail":"forall (f :: * -> * -> *).\nFromJSON2 f =>\nforall a b.\n(Value -> Parser a)\n-> (Value -> Parser [a])\n-> (Value -> Parser b)\n-> (Value -> Parser [b])\n-> Value\n-> Parser [f a b]\nData.Aeson.Utils"},{"kind":7,"data":"FromJSONKey module:Data.Aeson.Utils is:exact","label":"FromJSONKey","detail":"Data.Aeson.Utils"},{"kind":3,"data":"fromJSONKey module:Data.Aeson.Utils is:exact","label":"fromJSONKey","detail":"forall a. FromJSONKey a => FromJSONKeyFunction a\nData.Aeson.Utils"},{"kind":3,"data":"fromJSONKeyList module:Data.Aeson.Utils is:exact","label":"fromJSONKeyList","detail":"forall a. FromJSONKey a => FromJSONKeyFunction [a]\nData.Aeson.Utils"},{"kind":7,"data":"FromJSONKeyFunction module:Data.Aeson.Utils is:exact","label":"FromJSONKeyFunction","detail":"Data.Aeson.Utils"},{"kind":4,"data":"FromJSONKeyCoerce module:Data.Aeson.Utils is:exact","label":"FromJSONKeyCoerce","detail":"forall a. CoerceText a -> FromJSONKeyFunction a\nData.Aeson.Utils"},{"kind":4,"data":"FromJSONKeyText module:Data.Aeson.Utils is:exact","label":"FromJSONKeyText","detail":"forall a. (Text -> a) -> FromJSONKeyFunction a\nData.Aeson.Utils"},{"kind":4,"data":"FromJSONKeyTextParser module:Data.Aeson.Utils is:exact","label":"FromJSONKeyTextParser","detail":"forall a. (Text -> Parser a) -> FromJSONKeyFunction a\nData.Aeson.Utils"},{"kind":4,"data":"FromJSONKeyValue module:Data.Aeson.Utils is:exact","label":"FromJSONKeyValue","detail":"forall a. (Value -> Parser a) -> FromJSONKeyFunction a\nData.Aeson.Utils"},{"kind":7,"data":"GFromJSON module:Data.Aeson.Utils is:exact","label":"GFromJSON","detail":"Data.Aeson.Utils"},{"kind":3,"data":"fromDotNetTime module:Data.Aeson.Utils is:exact","label":"fromDotNetTime","detail":"DotNetTime -> UTCTime\nData.Aeson.Utils"},{"kind":3,"data":"constructorTagModifier module:Data.Aeson.Utils is:exact","label":"constructorTagModifier","detail":"Options -> String -> String\nData.Aeson.Utils"},{"kind":3,"data":"fieldLabelModifier module:Data.Aeson.Utils is:exact","label":"fieldLabelModifier","detail":"Options -> String -> String\nData.Aeson.Utils"},{"kind":3,"data":"omitNothingFields module:Data.Aeson.Utils is:exact","label":"omitNothingFields","detail":"Options -> Bool\nData.Aeson.Utils"},{"kind":4,"data":"ObjectWithSingleField module:Data.Aeson.Utils is:exact","label":"ObjectWithSingleField","detail":"SumEncoding\nData.Aeson.Utils"},{"kind":3,"data":"contentsFieldName module:Data.Aeson.Utils is:exact","label":"contentsFieldName","detail":"SumEncoding -> String\nData.Aeson.Utils"},{"kind":3,"data":"tagFieldName module:Data.Aeson.Utils is:exact","label":"tagFieldName","detail":"SumEncoding -> String\nData.Aeson.Utils"},{"kind":3,"data":"liftToEncoding module:Data.Aeson.Utils is:exact","label":"liftToEncoding","detail":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Encoding) -> ([a] -> Encoding) -> f a -> Encoding\nData.Aeson.Utils"},{"kind":3,"data":"liftToEncodingList module:Data.Aeson.Utils is:exact","label":"liftToEncodingList","detail":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Encoding) -> ([a] -> Encoding) -> [f a] -> Encoding\nData.Aeson.Utils"},{"kind":3,"data":"liftToJSON module:Data.Aeson.Utils is:exact","label":"liftToJSON","detail":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Value) -> ([a] -> Value) -> f a -> Value\nData.Aeson.Utils"},{"kind":3,"data":"liftToJSONList module:Data.Aeson.Utils is:exact","label":"liftToJSONList","detail":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Value) -> ([a] -> Value) -> [f a] -> Value\nData.Aeson.Utils"},{"kind":3,"data":"liftToEncoding2 module:Data.Aeson.Utils is:exact","label":"liftToEncoding2","detail":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Encoding)\n-> ([a] -> Encoding)\n-> (b -> Encoding)\n-> ([b] -> Encoding)\n-> f a b\n-> Encoding\nData.Aeson.Utils"},{"kind":3,"data":"liftToEncodingList2 module:Data.Aeson.Utils is:exact","label":"liftToEncodingList2","detail":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Encoding)\n-> ([a] -> Encoding)\n-> (b -> Encoding)\n-> ([b] -> Encoding)\n-> [f a b]\n-> Encoding\nData.Aeson.Utils"},{"kind":3,"data":"liftToJSON2 module:Data.Aeson.Utils is:exact","label":"liftToJSON2","detail":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Value)\n-> ([a] -> Value)\n-> (b -> Value)\n-> ([b] -> Value)\n-> f a b\n-> Value\nData.Aeson.Utils"},{"kind":3,"data":"liftToJSONList2 module:Data.Aeson.Utils is:exact","label":"liftToJSONList2","detail":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Value)\n-> ([a] -> Value)\n-> (b -> Value)\n-> ([b] -> Value)\n-> [f a b]\n-> Value\nData.Aeson.Utils"},{"kind":7,"data":"ToJSONKeyFunction module:Data.Aeson.Utils is:exact","label":"ToJSONKeyFunction","detail":"Data.Aeson.Utils"}],"jsonrpc":"2.0","id":25667}
01:03:31 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"ncm2#complete","params":[{"base":"f","bcol":28,"bufnr":1,"ccol":28,"changedtick":4164,"context_id":6916,"curpos":[0,44,28,0,28],"early_cache":false,"filepath":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","filetype":"haskell","lnum":44,"manual":0,"match_end":26,"matcher":{"name":"abbrfuzzy"},"scope":"haskell","scope_level":1,"scope_match":"haskell","source":{"auto_popup":1,"complete_pattern":["\\."],"early_cache":0,"enable":1,"mark":"LC","name":"LanguageClient_haskell","on_complete":"LanguageClient_NCM2OnComplete","priority":9,"ready":1,"scope":["haskell"],"subscope_enable":0},"startccol":27,"tick":[[0,44,28],80],"time":1535782000.0,"typed":"           (num |> AUtils.f","word_pattern":"(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)"},27,[{"abbr":"decodeFileStrict","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. FromJSON a => FilePath -> IO (Maybe a)\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"decodeFileStrict\",\"kind\":3,\"detail\":\"forall a. FromJSON a => FilePath -> IO (Maybe a)\\nData.Aeson.Utils\",\"data\":\"decodeFileStrict module:Data.Aeson.Utils is:exact\"}}","word":"decodeFileStrict"},{"abbr":"decodeFileStrict'","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. FromJSON a => FilePath -> IO (Maybe a)\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"decodeFileStrict'\",\"kind\":3,\"detail\":\"forall a. FromJSON a => FilePath -> IO (Maybe a)\\nData.Aeson.Utils\",\"data\":\"decodeFileStrict' module:Data.Aeson.Utils is:exact\"}}","word":"decodeFileStrict'"},{"abbr":"eitherDecodeFileStrict","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. FromJSON a => FilePath -> IO (Either String a)\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"eitherDecodeFileStrict\",\"kind\":3,\"detail\":\"forall a. FromJSON a => FilePath -> IO (Either String a)\\nData.Aeson.Utils\",\"data\":\"eitherDecodeFileStrict module:Data.Aeson.Utils is:exact\"}}","word":"eitherDecodeFileStrict"},{"abbr":"eitherDecodeFileStrict'","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. FromJSON a => FilePath -> IO (Either String a)\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"eitherDecodeFileStrict'\",\"kind\":3,\"detail\":\"forall a. FromJSON a => FilePath -> IO (Either String a)\\nData.Aeson.Utils\",\"data\":\"eitherDecodeFileStrict' module:Data.Aeson.Utils is:exact\"}}","word":"eitherDecodeFileStrict'"},{"abbr":"encodeFile","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. ToJSON a => FilePath -> a -> IO ()\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"encodeFile\",\"kind\":3,\"detail\":\"forall a. ToJSON a => FilePath -> a -> IO ()\\nData.Aeson.Utils\",\"data\":\"encodeFile module:Data.Aeson.Utils is:exact\"}}","word":"encodeFile"},{"abbr":"unsafeToEncoding","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. Builder -> Encoding' a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"unsafeToEncoding\",\"kind\":3,\"detail\":\"forall a. Builder -> Encoding' a\\nData.Aeson.Utils\",\"data\":\"unsafeToEncoding module:Data.Aeson.Utils is:exact\"}}","word":"unsafeToEncoding"},{"abbr":"foldable","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (t :: * -> *) a. (Foldable t, ToJSON a) => t a -> Encoding\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"foldable\",\"kind\":3,\"detail\":\"forall (t :: * -> *) a. (Foldable t, ToJSON a) => t a -> Encoding\\nData.Aeson.Utils\",\"data\":\"foldable module:Data.Aeson.Utils is:exact\"}}","word":"foldable"},{"abbr":"coerceFromJSONKeyFunction","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a b.\nCoercible a b =>\nFromJSONKeyFunction a -> FromJSONKeyFunction b\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"coerceFromJSONKeyFunction\",\"kind\":3,\"detail\":\"forall a b.\\nCoercible a b =>\\nFromJSONKeyFunction a -> FromJSONKeyFunction b\\nData.Aeson.Utils\",\"data\":\"coerceFromJSONKeyFunction module:Data.Aeson.Utils is:exact\"}}","word":"coerceFromJSONKeyFunction"},{"abbr":"explicitParseField","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. (Value -> Parser a) -> Object -> Text -> Parser a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"explicitParseField\",\"kind\":3,\"detail\":\"forall a. (Value -> Parser a) -> Object -> Text -> Parser a\\nData.Aeson.Utils\",\"data\":\"explicitParseField module:Data.Aeson.Utils is:exact\"}}","word":"explicitParseField"},{"abbr":"explicitParseFieldMaybe","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. (Value -> Parser a) -> Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"explicitParseFieldMaybe\",\"kind\":3,\"detail\":\"forall a. (Value -> Parser a) -> Object -> Text -> Parser (Maybe a)\\nData.Aeson.Utils\",\"data\":\"explicitParseFieldMaybe module:Data.Aeson.Utils is:exact\"}}","word":"explicitParseFieldMaybe"},{"abbr":"explicitParseFieldMaybe'","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. (Value -> Parser a) -> Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"explicitParseFieldMaybe'\",\"kind\":3,\"detail\":\"forall a. (Value -> Parser a) -> Object -> Text -> Parser (Maybe a)\\nData.Aeson.Utils\",\"data\":\"explicitParseFieldMaybe' module:Data.Aeson.Utils is:exact\"}}","word":"explicitParseFieldMaybe'"},{"abbr":"fromJSON","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. FromJSON a => Value -> Result a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"fromJSON\",\"kind\":3,\"detail\":\"forall a. FromJSON a => Value -> Result a\\nData.Aeson.Utils\",\"data\":\"fromJSON module:Data.Aeson.Utils is:exact\"}}","word":"fromJSON"},{"abbr":"fromJSONKeyCoerce","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. Coercible Text a => FromJSONKeyFunction a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"fromJSONKeyCoerce\",\"kind\":3,\"detail\":\"forall a. Coercible Text a => FromJSONKeyFunction a\\nData.Aeson.Utils\",\"data\":\"fromJSONKeyCoerce module:Data.Aeson.Utils is:exact\"}}","word":"fromJSONKeyCoerce"},{"abbr":"genericLiftParseJSON","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> *) a.\n(Generic1 f, GFromJSON One (Rep1 f)) =>\nOptions\n-> (Value -> Parser a)\n-> (Value -> Parser [a])\n-> Value\n-> Parser (f a)\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"genericLiftParseJSON\",\"kind\":3,\"detail\":\"forall (f :: * -> *) a.\\n(Generic1 f, GFromJSON One (Rep1 f)) =>\\nOptions\\n-> (Value -> Parser a)\\n-> (Value -> Parser [a])\\n-> Value\\n-> Parser (f a)\\nData.Aeson.Utils\",\"data\":\"genericLiftParseJSON module:Data.Aeson.Utils is:exact\"}}","word":"genericLiftParseJSON"},{"abbr":"mapFromJSONKeyFunction","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a b.\n(a -> b) -> FromJSONKeyFunction a -> FromJSONKeyFunction b\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"mapFromJSONKeyFunction\",\"kind\":3,\"detail\":\"forall a b.\\n(a -> b) -> FromJSONKeyFunction a -> FromJSONKeyFunction b\\nData.Aeson.Utils\",\"data\":\"mapFromJSONKeyFunction module:Data.Aeson.Utils is:exact\"}}","word":"mapFromJSONKeyFunction"},{"abbr":"parseField","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. FromJSON a => Object -> Text -> Parser a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"parseField\",\"kind\":3,\"detail\":\"forall a. FromJSON a => Object -> Text -> Parser a\\nData.Aeson.Utils\",\"data\":\"parseField module:Data.Aeson.Utils is:exact\"}}","word":"parseField"},{"abbr":"parseFieldMaybe","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. FromJSON a => Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"parseFieldMaybe\",\"kind\":3,\"detail\":\"forall a. FromJSON a => Object -> Text -> Parser (Maybe a)\\nData.Aeson.Utils\",\"data\":\"parseFieldMaybe module:Data.Aeson.Utils is:exact\"}}","word":"parseFieldMaybe"},{"abbr":"parseFieldMaybe'","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. FromJSON a => Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"parseFieldMaybe'\",\"kind\":3,\"detail\":\"forall a. FromJSON a => Object -> Text -> Parser (Maybe a)\\nData.Aeson.Utils\",\"data\":\"parseFieldMaybe' module:Data.Aeson.Utils is:exact\"}}","word":"parseFieldMaybe'"},{"abbr":"withScientific","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. String -> (Scientific -> Parser a) -> Value -> Parser a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"withScientific\",\"kind\":3,\"detail\":\"forall a. String -> (Scientific -> Parser a) -> Value -> Parser a\\nData.Aeson.Utils\",\"data\":\"withScientific module:Data.Aeson.Utils is:exact\"}}","word":"withScientific"},{"abbr":"defaultOptions","dup":1,"icase":1,"info":"","kind":"Function","menu":"Options\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"defaultOptions\",\"kind\":3,\"detail\":\"Options\\nData.Aeson.Utils\",\"data\":\"defaultOptions module:Data.Aeson.Utils is:exact\"}}","word":"defaultOptions"},{"abbr":"defaultTaggedObject","dup":1,"icase":1,"info":"","kind":"Function","menu":"SumEncoding\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"defaultTaggedObject\",\"kind\":3,\"detail\":\"SumEncoding\\nData.Aeson.Utils\",\"data\":\"defaultTaggedObject module:Data.Aeson.Utils is:exact\"}}","word":"defaultTaggedObject"},{"abbr":"modifyFailure","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. (String -> String) -> Parser a -> Parser a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"modifyFailure\",\"kind\":3,\"detail\":\"forall a. (String -> String) -> Parser a -> Parser a\\nData.Aeson.Utils\",\"data\":\"modifyFailure module:Data.Aeson.Utils is:exact\"}}","word":"modifyFailure"},{"abbr":"contramapToJSONKeyFunction","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall b a. (b -> a) -> ToJSONKeyFunction a -> ToJSONKeyFunction b\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"contramapToJSONKeyFunction\",\"kind\":3,\"detail\":\"forall b a. (b -> a) -> ToJSONKeyFunction a -> ToJSONKeyFunction b\\nData.Aeson.Utils\",\"data\":\"contramapToJSONKeyFunction module:Data.Aeson.Utils is:exact\"}}","word":"contramapToJSONKeyFunction"},{"abbr":"genericLiftToEncoding","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> *) a.\n(Generic1 f, GToJSON Encoding One (Rep1 f)) =>\nOptions -> (a -> Encoding) -> ([a] -> Encoding) -> f a -> Encoding\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"genericLiftToEncoding\",\"kind\":3,\"detail\":\"forall (f :: * -> *) a.\\n(Generic1 f, GToJSON Encoding One (Rep1 f)) =>\\nOptions -> (a -> Encoding) -> ([a] -> Encoding) -> f a -> Encoding\\nData.Aeson.Utils\",\"data\":\"genericLiftToEncoding module:Data.Aeson.Utils is:exact\"}}","word":"genericLiftToEncoding"},{"abbr":"genericLiftToJSON","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> *) a.\n(Generic1 f, GToJSON Value One (Rep1 f)) =>\nOptions -> (a -> Value) -> ([a] -> Value) -> f a -> Value\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"genericLiftToJSON\",\"kind\":3,\"detail\":\"forall (f :: * -> *) a.\\n(Generic1 f, GToJSON Value One (Rep1 f)) =>\\nOptions -> (a -> Value) -> ([a] -> Value) -> f a -> Value\\nData.Aeson.Utils\",\"data\":\"genericLiftToJSON module:Data.Aeson.Utils is:exact\"}}","word":"genericLiftToJSON"},{"abbr":"floatingOrInteger","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall r i. (RealFloat r, Integral i) => Scientific -> Either r i\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"floatingOrInteger\",\"kind\":3,\"detail\":\"forall r i. (RealFloat r, Integral i) => Scientific -> Either r i\\nData.Aeson.Utils\",\"data\":\"floatingOrInteger module:Data.Aeson.Utils is:exact\"}}","word":"floatingOrInteger"},{"abbr":"fromFloatDigits","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. RealFloat a => a -> Scientific\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"fromFloatDigits\",\"kind\":3,\"detail\":\"forall a. RealFloat a => a -> Scientific\\nData.Aeson.Utils\",\"data\":\"fromFloatDigits module:Data.Aeson.Utils is:exact\"}}","word":"fromFloatDigits"},{"abbr":"fromEncoding","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall tag. Encoding' tag -> Builder\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"fromEncoding\",\"kind\":3,\"detail\":\"forall tag. Encoding' tag -> Builder\\nData.Aeson.Utils\",\"data\":\"fromEncoding module:Data.Aeson.Utils is:exact\"}}","word":"fromEncoding"},{"abbr":"FromArgs","dup":1,"icase":1,"info":"","kind":"Class","menu":"Data.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"FromArgs\",\"kind\":7,\"detail\":\"Data.Aeson.Utils\",\"data\":\"FromArgs module:Data.Aeson.Utils is:exact\"}}","word":"FromArgs"},{"abbr":"From1Args","dup":1,"icase":1,"info":"","kind":"Constructor","menu":"forall a.\n(Value -> Parser a) -> (Value -> Parser [a]) -> FromArgs One a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"From1Args\",\"kind\":4,\"detail\":\"forall a.\\n(Value -> Parser a) -> (Value -> Parser [a]) -> FromArgs One a\\nData.Aeson.Utils\",\"data\":\"From1Args module:Data.Aeson.Utils is:exact\"}}","word":"From1Args"},{"abbr":"NoFromArgs","dup":1,"icase":1,"info":"","kind":"Constructor","menu":"forall a. FromArgs Zero a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"NoFromArgs\",\"kind\":4,\"detail\":\"forall a. FromArgs Zero a\\nData.Aeson.Utils\",\"data\":\"NoFromArgs module:Data.Aeson.Utils is:exact\"}}","word":"NoFromArgs"},{"abbr":"FromJSON","dup":1,"icase":1,"info":"","kind":"Class","menu":"Data.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"FromJSON\",\"kind\":7,\"detail\":\"Data.Aeson.Utils\",\"data\":\"FromJSON module:Data.Aeson.Utils is:exact\"}}","word":"FromJSON"},{"abbr":"FromJSON1","dup":1,"icase":1,"info":"","kind":"Class","menu":"Data.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"FromJSON1\",\"kind\":7,\"detail\":\"Data.Aeson.Utils\",\"data\":\"FromJSON1 module:Data.Aeson.Utils is:exact\"}}","word":"FromJSON1"},{"abbr":"liftParseJSON","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> *).\nFromJSON1 f =>\nforall a.\n(Value -> Parser a)\n-> (Value -> Parser [a]) -> Value -> Parser (f a)\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftParseJSON\",\"kind\":3,\"detail\":\"forall (f :: * -> *).\\nFromJSON1 f =>\\nforall a.\\n(Value -> Parser a)\\n-> (Value -> Parser [a]) -> Value -> Parser (f a)\\nData.Aeson.Utils\",\"data\":\"liftParseJSON module:Data.Aeson.Utils is:exact\"}}","word":"liftParseJSON"},{"abbr":"liftParseJSONList","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> *).\nFromJSON1 f =>\nforall a.\n(Value -> Parser a)\n-> (Value -> Parser [a]) -> Value -> Parser [f a]\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftParseJSONList\",\"kind\":3,\"detail\":\"forall (f :: * -> *).\\nFromJSON1 f =>\\nforall a.\\n(Value -> Parser a)\\n-> (Value -> Parser [a]) -> Value -> Parser [f a]\\nData.Aeson.Utils\",\"data\":\"liftParseJSONList module:Data.Aeson.Utils is:exact\"}}","word":"liftParseJSONList"},{"abbr":"FromJSON2","dup":1,"icase":1,"info":"","kind":"Class","menu":"Data.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"FromJSON2\",\"kind\":7,\"detail\":\"Data.Aeson.Utils\",\"data\":\"FromJSON2 module:Data.Aeson.Utils is:exact\"}}","word":"FromJSON2"},{"abbr":"liftParseJSON2","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> * -> *).\nFromJSON2 f =>\nforall a b.\n(Value -> Parser a)\n-> (Value -> Parser [a])\n-> (Value -> Parser b)\n-> (Value -> Parser [b])\n-> Value\n-> Parser (f a b)\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftParseJSON2\",\"kind\":3,\"detail\":\"forall (f :: * -> * -> *).\\nFromJSON2 f =>\\nforall a b.\\n(Value -> Parser a)\\n-> (Value -> Parser [a])\\n-> (Value -> Parser b)\\n-> (Value -> Parser [b])\\n-> Value\\n-> Parser (f a b)\\nData.Aeson.Utils\",\"data\":\"liftParseJSON2 module:Data.Aeson.Utils is:exact\"}}","word":"liftParseJSON2"},{"abbr":"liftParseJSONList2","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> * -> *).\nFromJSON2 f =>\nforall a b.\n(Value -> Parser a)\n-> (Value -> Parser [a])\n-> (Value -> Parser b)\n-> (Value -> Parser [b])\n-> Value\n-> Parser [f a b]\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftParseJSONList2\",\"kind\":3,\"detail\":\"forall (f :: * -> * -> *).\\nFromJSON2 f =>\\nforall a b.\\n(Value -> Parser a)\\n-> (Value -> Parser [a])\\n-> (Value -> Parser b)\\n-> (Value -> Parser [b])\\n-> Value\\n-> Parser [f a b]\\nData.Aeson.Utils\",\"data\":\"liftParseJSONList2 module:Data.Aeson.Utils is:exact\"}}","word":"liftParseJSONList2"},{"abbr":"FromJSONKey","dup":1,"icase":1,"info":"","kind":"Class","menu":"Data.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"FromJSONKey\",\"kind\":7,\"detail\":\"Data.Aeson.Utils\",\"data\":\"FromJSONKey module:Data.Aeson.Utils is:exact\"}}","word":"FromJSONKey"},{"abbr":"fromJSONKey","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. FromJSONKey a => FromJSONKeyFunction a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"fromJSONKey\",\"kind\":3,\"detail\":\"forall a. FromJSONKey a => FromJSONKeyFunction a\\nData.Aeson.Utils\",\"data\":\"fromJSONKey module:Data.Aeson.Utils is:exact\"}}","word":"fromJSONKey"},{"abbr":"fromJSONKeyList","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. FromJSONKey a => FromJSONKeyFunction [a]\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"fromJSONKeyList\",\"kind\":3,\"detail\":\"forall a. FromJSONKey a => FromJSONKeyFunction [a]\\nData.Aeson.Utils\",\"data\":\"fromJSONKeyList module:Data.Aeson.Utils is:exact\"}}","word":"fromJSONKeyList"},{"abbr":"FromJSONKeyFunction","dup":1,"icase":1,"info":"","kind":"Class","menu":"Data.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"FromJSONKeyFunction\",\"kind\":7,\"detail\":\"Data.Aeson.Utils\",\"data\":\"FromJSONKeyFunction module:Data.Aeson.Utils is:exact\"}}","word":"FromJSONKeyFunction"},{"abbr":"FromJSONKeyCoerce","dup":1,"icase":1,"info":"","kind":"Constructor","menu":"forall a. CoerceText a -> FromJSONKeyFunction a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"FromJSONKeyCoerce\",\"kind\":4,\"detail\":\"forall a. CoerceText a -> FromJSONKeyFunction a\\nData.Aeson.Utils\",\"data\":\"FromJSONKeyCoerce module:Data.Aeson.Utils is:exact\"}}","word":"FromJSONKeyCoerce"},{"abbr":"FromJSONKeyText","dup":1,"icase":1,"info":"","kind":"Constructor","menu":"forall a. (Text -> a) -> FromJSONKeyFunction a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"FromJSONKeyText\",\"kind\":4,\"detail\":\"forall a. (Text -> a) -> FromJSONKeyFunction a\\nData.Aeson.Utils\",\"data\":\"FromJSONKeyText module:Data.Aeson.Utils is:exact\"}}","word":"FromJSONKeyText"},{"abbr":"FromJSONKeyTextParser","dup":1,"icase":1,"info":"","kind":"Constructor","menu":"forall a. (Text -> Parser a) -> FromJSONKeyFunction a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"FromJSONKeyTextParser\",\"kind\":4,\"detail\":\"forall a. (Text -> Parser a) -> FromJSONKeyFunction a\\nData.Aeson.Utils\",\"data\":\"FromJSONKeyTextParser module:Data.Aeson.Utils is:exact\"}}","word":"FromJSONKeyTextParser"},{"abbr":"FromJSONKeyValue","dup":1,"icase":1,"info":"","kind":"Constructor","menu":"forall a. (Value -> Parser a) -> FromJSONKeyFunction a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"FromJSONKeyValue\",\"kind\":4,\"detail\":\"forall a. (Value -> Parser a) -> FromJSONKeyFunction a\\nData.Aeson.Utils\",\"data\":\"FromJSONKeyValue module:Data.Aeson.Utils is:exact\"}}","word":"FromJSONKeyValue"},{"abbr":"GFromJSON","dup":1,"icase":1,"info":"","kind":"Class","menu":"Data.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"GFromJSON\",\"kind\":7,\"detail\":\"Data.Aeson.Utils\",\"data\":\"GFromJSON module:Data.Aeson.Utils is:exact\"}}","word":"GFromJSON"},{"abbr":"fromDotNetTime","dup":1,"icase":1,"info":"","kind":"Function","menu":"DotNetTime -> UTCTime\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"fromDotNetTime\",\"kind\":3,\"detail\":\"DotNetTime -> UTCTime\\nData.Aeson.Utils\",\"data\":\"fromDotNetTime module:Data.Aeson.Utils is:exact\"}}","word":"fromDotNetTime"},{"abbr":"constructorTagModifier","dup":1,"icase":1,"info":"","kind":"Function","menu":"Options -> String -> String\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"constructorTagModifier\",\"kind\":3,\"detail\":\"Options -> String -> String\\nData.Aeson.Utils\",\"data\":\"constructorTagModifier module:Data.Aeson.Utils is:exact\"}}","word":"constructorTagModifier"},{"abbr":"fieldLabelModifier","dup":1,"icase":1,"info":"","kind":"Function","menu":"Options -> String -> String\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"fieldLabelModifier\",\"kind\":3,\"detail\":\"Options -> String -> String\\nData.Aeson.Utils\",\"data\":\"fieldLabelModifier module:Data.Aeson.Utils is:exact\"}}","word":"fieldLabelModifier"},{"abbr":"omitNothingFields","dup":1,"icase":1,"info":"","kind":"Function","menu":"Options -> Bool\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"omitNothingFields\",\"kind\":3,\"detail\":\"Options -> Bool\\nData.Aeson.Utils\",\"data\":\"omitNothingFields module:Data.Aeson.Utils is:exact\"}}","word":"omitNothingFields"},{"abbr":"ObjectWithSingleField","dup":1,"icase":1,"info":"","kind":"Constructor","menu":"SumEncoding\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"ObjectWithSingleField\",\"kind\":4,\"detail\":\"SumEncoding\\nData.Aeson.Utils\",\"data\":\"ObjectWithSingleField module:Data.Aeson.Utils is:exact\"}}","word":"ObjectWithSingleField"},{"abbr":"contentsFieldName","dup":1,"icase":1,"info":"","kind":"Function","menu":"SumEncoding -> String\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"contentsFieldName\",\"kind\":3,\"detail\":\"SumEncoding -> String\\nData.Aeson.Utils\",\"data\":\"contentsFieldName module:Data.Aeson.Utils is:exact\"}}","word":"contentsFieldName"},{"abbr":"tagFieldName","dup":1,"icase":1,"info":"","kind":"Function","menu":"SumEncoding -> String\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"tagFieldName\",\"kind\":3,\"detail\":\"SumEncoding -> String\\nData.Aeson.Utils\",\"data\":\"tagFieldName module:Data.Aeson.Utils is:exact\"}}","word":"tagFieldName"},{"abbr":"liftToEncoding","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Encoding) -> ([a] -> Encoding) -> f a -> Encoding\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftToEncoding\",\"kind\":3,\"detail\":\"forall (f :: * -> *).\\nToJSON1 f =>\\nforall a. (a -> Encoding) -> ([a] -> Encoding) -> f a -> Encoding\\nData.Aeson.Utils\",\"data\":\"liftToEncoding module:Data.Aeson.Utils is:exact\"}}","word":"liftToEncoding"},{"abbr":"liftToEncodingList","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Encoding) -> ([a] -> Encoding) -> [f a] -> Encoding\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftToEncodingList\",\"kind\":3,\"detail\":\"forall (f :: * -> *).\\nToJSON1 f =>\\nforall a. (a -> Encoding) -> ([a] -> Encoding) -> [f a] -> Encoding\\nData.Aeson.Utils\",\"data\":\"liftToEncodingList module:Data.Aeson.Utils is:exact\"}}","word":"liftToEncodingList"},{"abbr":"liftToJSON","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Value) -> ([a] -> Value) -> f a -> Value\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftToJSON\",\"kind\":3,\"detail\":\"forall (f :: * -> *).\\nToJSON1 f =>\\nforall a. (a -> Value) -> ([a] -> Value) -> f a -> Value\\nData.Aeson.Utils\",\"data\":\"liftToJSON module:Data.Aeson.Utils is:exact\"}}","word":"liftToJSON"},{"abbr":"liftToJSONList","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Value) -> ([a] -> Value) -> [f a] -> Value\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftToJSONList\",\"kind\":3,\"detail\":\"forall (f :: * -> *).\\nToJSON1 f =>\\nforall a. (a -> Value) -> ([a] -> Value) -> [f a] -> Value\\nData.Aeson.Utils\",\"data\":\"liftToJSONList module:Data.Aeson.Utils is:exact\"}}","word":"liftToJSONList"},{"abbr":"liftToEncoding2","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Encoding)\n-> ([a] -> Encoding)\n-> (b -> Encoding)\n-> ([b] -> Encoding)\n-> f a b\n-> Encoding\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftToEncoding2\",\"kind\":3,\"detail\":\"forall (f :: * -> * -> *).\\nToJSON2 f =>\\nforall a b.\\n(a -> Encoding)\\n-> ([a] -> Encoding)\\n-> (b -> Encoding)\\n-> ([b] -> Encoding)\\n-> f a b\\n-> Encoding\\nData.Aeson.Utils\",\"data\":\"liftToEncoding2 module:Data.Aeson.Utils is:exact\"}}","word":"liftToEncoding2"},{"abbr":"liftToEncodingList2","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Encoding)\n-> ([a] -> Encoding)\n-> (b -> Encoding)\n-> ([b] -> Encoding)\n-> [f a b]\n-> Encoding\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftToEncodingList2\",\"kind\":3,\"detail\":\"forall (f :: * -> * -> *).\\nToJSON2 f =>\\nforall a b.\\n(a -> Encoding)\\n-> ([a] -> Encoding)\\n-> (b -> Encoding)\\n-> ([b] -> Encoding)\\n-> [f a b]\\n-> Encoding\\nData.Aeson.Utils\",\"data\":\"liftToEncodingList2 module:Data.Aeson.Utils is:exact\"}}","word":"liftToEncodingList2"},{"abbr":"liftToJSON2","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Value)\n-> ([a] -> Value)\n-> (b -> Value)\n-> ([b] -> Value)\n-> f a b\n-> Value\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftToJSON2\",\"kind\":3,\"detail\":\"forall (f :: * -> * -> *).\\nToJSON2 f =>\\nforall a b.\\n(a -> Value)\\n-> ([a] -> Value)\\n-> (b -> Value)\\n-> ([b] -> Value)\\n-> f a b\\n-> Value\\nData.Aeson.Utils\",\"data\":\"liftToJSON2 module:Data.Aeson.Utils is:exact\"}}","word":"liftToJSON2"},{"abbr":"liftToJSONList2","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Value)\n-> ([a] -> Value)\n-> (b -> Value)\n-> ([b] -> Value)\n-> [f a b]\n-> Value\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftToJSONList2\",\"kind\":3,\"detail\":\"forall (f :: * -> * -> *).\\nToJSON2 f =>\\nforall a b.\\n(a -> Value)\\n-> ([a] -> Value)\\n-> (b -> Value)\\n-> ([b] -> Value)\\n-> [f a b]\\n-> Value\\nData.Aeson.Utils\",\"data\":\"liftToJSONList2 module:Data.Aeson.Utils is:exact\"}}","word":"liftToJSONList2"},{"abbr":"ToJSONKeyFunction","dup":1,"icase":1,"info":"","kind":"Class","menu":"Data.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"ToJSONKeyFunction\",\"kind\":7,\"detail\":\"Data.Aeson.Utils\",\"data\":\"ToJSONKeyFunction module:Data.Aeson.Utils is:exact\"}}","word":"ToJSONKeyFunction"}],false],"id":25668}
01:03:31 INFO reader-main src/vim.rs:380 <= None {"id": 25668, "jsonrpc": "2.0", "result": 0}
01:03:31 INFO main src/languageclient.rs:2540 End LanguageClient_NCM2OnComplete
01:03:31 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","result":[{"data":"decodeFileStrict module:Data.Aeson.Utils is:exact","detail":"forall a. FromJSON a => FilePath -> IO (Maybe a)\nData.Aeson.Utils","kind":3,"label":"decodeFileStrict"},{"data":"decodeFileStrict' module:Data.Aeson.Utils is:exact","detail":"forall a. FromJSON a => FilePath -> IO (Maybe a)\nData.Aeson.Utils","kind":3,"label":"decodeFileStrict'"},{"data":"eitherDecodeFileStrict module:Data.Aeson.Utils is:exact","detail":"forall a. FromJSON a => FilePath -> IO (Either String a)\nData.Aeson.Utils","kind":3,"label":"eitherDecodeFileStrict"},{"data":"eitherDecodeFileStrict' module:Data.Aeson.Utils is:exact","detail":"forall a. FromJSON a => FilePath -> IO (Either String a)\nData.Aeson.Utils","kind":3,"label":"eitherDecodeFileStrict'"},{"data":"encodeFile module:Data.Aeson.Utils is:exact","detail":"forall a. ToJSON a => FilePath -> a -> IO ()\nData.Aeson.Utils","kind":3,"label":"encodeFile"},{"data":"unsafeToEncoding module:Data.Aeson.Utils is:exact","detail":"forall a. Builder -> Encoding' a\nData.Aeson.Utils","kind":3,"label":"unsafeToEncoding"},{"data":"foldable module:Data.Aeson.Utils is:exact","detail":"forall (t :: * -> *) a. (Foldable t, ToJSON a) => t a -> Encoding\nData.Aeson.Utils","kind":3,"label":"foldable"},{"data":"coerceFromJSONKeyFunction module:Data.Aeson.Utils is:exact","detail":"forall a b.\nCoercible a b =>\nFromJSONKeyFunction a -> FromJSONKeyFunction b\nData.Aeson.Utils","kind":3,"label":"coerceFromJSONKeyFunction"},{"data":"explicitParseField module:Data.Aeson.Utils is:exact","detail":"forall a. (Value -> Parser a) -> Object -> Text -> Parser a\nData.Aeson.Utils","kind":3,"label":"explicitParseField"},{"data":"explicitParseFieldMaybe module:Data.Aeson.Utils is:exact","detail":"forall a. (Value -> Parser a) -> Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils","kind":3,"label":"explicitParseFieldMaybe"},{"data":"explicitParseFieldMaybe' module:Data.Aeson.Utils is:exact","detail":"forall a. (Value -> Parser a) -> Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils","kind":3,"label":"explicitParseFieldMaybe'"},{"data":"fromJSON module:Data.Aeson.Utils is:exact","detail":"forall a. FromJSON a => Value -> Result a\nData.Aeson.Utils","kind":3,"label":"fromJSON"},{"data":"fromJSONKeyCoerce module:Data.Aeson.Utils is:exact","detail":"forall a. Coercible Text a => FromJSONKeyFunction a\nData.Aeson.Utils","kind":3,"label":"fromJSONKeyCoerce"},{"data":"genericLiftParseJSON module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> *) a.\n(Generic1 f, GFromJSON One (Rep1 f)) =>\nOptions\n-> (Value -> Parser a)\n-> (Value -> Parser [a])\n-> Value\n-> Parser (f a)\nData.Aeson.Utils","kind":3,"label":"genericLiftParseJSON"},{"data":"mapFromJSONKeyFunction module:Data.Aeson.Utils is:exact","detail":"forall a b.\n(a -> b) -> FromJSONKeyFunction a -> FromJSONKeyFunction b\nData.Aeson.Utils","kind":3,"label":"mapFromJSONKeyFunction"},{"data":"parseField module:Data.Aeson.Utils is:exact","detail":"forall a. FromJSON a => Object -> Text -> Parser a\nData.Aeson.Utils","kind":3,"label":"parseField"},{"data":"parseFieldMaybe module:Data.Aeson.Utils is:exact","detail":"forall a. FromJSON a => Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils","kind":3,"label":"parseFieldMaybe"},{"data":"parseFieldMaybe' module:Data.Aeson.Utils is:exact","detail":"forall a. FromJSON a => Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils","kind":3,"label":"parseFieldMaybe'"},{"data":"withScientific module:Data.Aeson.Utils is:exact","detail":"forall a. String -> (Scientific -> Parser a) -> Value -> Parser a\nData.Aeson.Utils","kind":3,"label":"withScientific"},{"data":"defaultOptions module:Data.Aeson.Utils is:exact","detail":"Options\nData.Aeson.Utils","kind":3,"label":"defaultOptions"},{"data":"defaultTaggedObject module:Data.Aeson.Utils is:exact","detail":"SumEncoding\nData.Aeson.Utils","kind":3,"label":"defaultTaggedObject"},{"data":"modifyFailure module:Data.Aeson.Utils is:exact","detail":"forall a. (String -> String) -> Parser a -> Parser a\nData.Aeson.Utils","kind":3,"label":"modifyFailure"},{"data":"contramapToJSONKeyFunction module:Data.Aeson.Utils is:exact","detail":"forall b a. (b -> a) -> ToJSONKeyFunction a -> ToJSONKeyFunction b\nData.Aeson.Utils","kind":3,"label":"contramapToJSONKeyFunction"},{"data":"genericLiftToEncoding module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> *) a.\n(Generic1 f, GToJSON Encoding One (Rep1 f)) =>\nOptions -> (a -> Encoding) -> ([a] -> Encoding) -> f a -> Encoding\nData.Aeson.Utils","kind":3,"label":"genericLiftToEncoding"},{"data":"genericLiftToJSON module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> *) a.\n(Generic1 f, GToJSON Value One (Rep1 f)) =>\nOptions -> (a -> Value) -> ([a] -> Value) -> f a -> Value\nData.Aeson.Utils","kind":3,"label":"genericLiftToJSON"},{"data":"floatingOrInteger module:Data.Aeson.Utils is:exact","detail":"forall r i. (RealFloat r, Integral i) => Scientific -> Either r i\nData.Aeson.Utils","kind":3,"label":"floatingOrInteger"},{"data":"fromFloatDigits module:Data.Aeson.Utils is:exact","detail":"forall a. RealFloat a => a -> Scientific\nData.Aeson.Utils","kind":3,"label":"fromFloatDigits"},{"data":"fromEncoding module:Data.Aeson.Utils is:exact","detail":"forall tag. Encoding' tag -> Builder\nData.Aeson.Utils","kind":3,"label":"fromEncoding"},{"data":"FromArgs module:Data.Aeson.Utils is:exact","detail":"Data.Aeson.Utils","kind":7,"label":"FromArgs"},{"data":"From1Args module:Data.Aeson.Utils is:exact","detail":"forall a.\n(Value -> Parser a) -> (Value -> Parser [a]) -> FromArgs One a\nData.Aeson.Utils","kind":4,"label":"From1Args"},{"data":"NoFromArgs module:Data.Aeson.Utils is:exact","detail":"forall a. FromArgs Zero a\nData.Aeson.Utils","kind":4,"label":"NoFromArgs"},{"data":"FromJSON module:Data.Aeson.Utils is:exact","detail":"Data.Aeson.Utils","kind":7,"label":"FromJSON"},{"data":"FromJSON1 module:Data.Aeson.Utils is:exact","detail":"Data.Aeson.Utils","kind":7,"label":"FromJSON1"},{"data":"liftParseJSON module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> *).\nFromJSON1 f =>\nforall a.\n(Value -> Parser a)\n-> (Value -> Parser [a]) -> Value -> Parser (f a)\nData.Aeson.Utils","kind":3,"label":"liftParseJSON"},{"data":"liftParseJSONList module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> *).\nFromJSON1 f =>\nforall a.\n(Value -> Parser a)\n-> (Value -> Parser [a]) -> Value -> Parser [f a]\nData.Aeson.Utils","kind":3,"label":"liftParseJSONList"},{"data":"FromJSON2 module:Data.Aeson.Utils is:exact","detail":"Data.Aeson.Utils","kind":7,"label":"FromJSON2"},{"data":"liftParseJSON2 module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> * -> *).\nFromJSON2 f =>\nforall a b.\n(Value -> Parser a)\n-> (Value -> Parser [a])\n-> (Value -> Parser b)\n-> (Value -> Parser [b])\n-> Value\n-> Parser (f a b)\nData.Aeson.Utils","kind":3,"label":"liftParseJSON2"},{"data":"liftParseJSONList2 module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> * -> *).\nFromJSON2 f =>\nforall a b.\n(Value -> Parser a)\n-> (Value -> Parser [a])\n-> (Value -> Parser b)\n-> (Value -> Parser [b])\n-> Value\n-> Parser [f a b]\nData.Aeson.Utils","kind":3,"label":"liftParseJSONList2"},{"data":"FromJSONKey module:Data.Aeson.Utils is:exact","detail":"Data.Aeson.Utils","kind":7,"label":"FromJSONKey"},{"data":"fromJSONKey module:Data.Aeson.Utils is:exact","detail":"forall a. FromJSONKey a => FromJSONKeyFunction a\nData.Aeson.Utils","kind":3,"label":"fromJSONKey"},{"data":"fromJSONKeyList module:Data.Aeson.Utils is:exact","detail":"forall a. FromJSONKey a => FromJSONKeyFunction [a]\nData.Aeson.Utils","kind":3,"label":"fromJSONKeyList"},{"data":"FromJSONKeyFunction module:Data.Aeson.Utils is:exact","detail":"Data.Aeson.Utils","kind":7,"label":"FromJSONKeyFunction"},{"data":"FromJSONKeyCoerce module:Data.Aeson.Utils is:exact","detail":"forall a. CoerceText a -> FromJSONKeyFunction a\nData.Aeson.Utils","kind":4,"label":"FromJSONKeyCoerce"},{"data":"FromJSONKeyText module:Data.Aeson.Utils is:exact","detail":"forall a. (Text -> a) -> FromJSONKeyFunction a\nData.Aeson.Utils","kind":4,"label":"FromJSONKeyText"},{"data":"FromJSONKeyTextParser module:Data.Aeson.Utils is:exact","detail":"forall a. (Text -> Parser a) -> FromJSONKeyFunction a\nData.Aeson.Utils","kind":4,"label":"FromJSONKeyTextParser"},{"data":"FromJSONKeyValue module:Data.Aeson.Utils is:exact","detail":"forall a. (Value -> Parser a) -> FromJSONKeyFunction a\nData.Aeson.Utils","kind":4,"label":"FromJSONKeyValue"},{"data":"GFromJSON module:Data.Aeson.Utils is:exact","detail":"Data.Aeson.Utils","kind":7,"label":"GFromJSON"},{"data":"fromDotNetTime module:Data.Aeson.Utils is:exact","detail":"DotNetTime -> UTCTime\nData.Aeson.Utils","kind":3,"label":"fromDotNetTime"},{"data":"constructorTagModifier module:Data.Aeson.Utils is:exact","detail":"Options -> String -> String\nData.Aeson.Utils","kind":3,"label":"constructorTagModifier"},{"data":"fieldLabelModifier module:Data.Aeson.Utils is:exact","detail":"Options -> String -> String\nData.Aeson.Utils","kind":3,"label":"fieldLabelModifier"},{"data":"omitNothingFields module:Data.Aeson.Utils is:exact","detail":"Options -> Bool\nData.Aeson.Utils","kind":3,"label":"omitNothingFields"},{"data":"ObjectWithSingleField module:Data.Aeson.Utils is:exact","detail":"SumEncoding\nData.Aeson.Utils","kind":4,"label":"ObjectWithSingleField"},{"data":"contentsFieldName module:Data.Aeson.Utils is:exact","detail":"SumEncoding -> String\nData.Aeson.Utils","kind":3,"label":"contentsFieldName"},{"data":"tagFieldName module:Data.Aeson.Utils is:exact","detail":"SumEncoding -> String\nData.Aeson.Utils","kind":3,"label":"tagFieldName"},{"data":"liftToEncoding module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Encoding) -> ([a] -> Encoding) -> f a -> Encoding\nData.Aeson.Utils","kind":3,"label":"liftToEncoding"},{"data":"liftToEncodingList module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Encoding) -> ([a] -> Encoding) -> [f a] -> Encoding\nData.Aeson.Utils","kind":3,"label":"liftToEncodingList"},{"data":"liftToJSON module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Value) -> ([a] -> Value) -> f a -> Value\nData.Aeson.Utils","kind":3,"label":"liftToJSON"},{"data":"liftToJSONList module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Value) -> ([a] -> Value) -> [f a] -> Value\nData.Aeson.Utils","kind":3,"label":"liftToJSONList"},{"data":"liftToEncoding2 module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Encoding)\n-> ([a] -> Encoding)\n-> (b -> Encoding)\n-> ([b] -> Encoding)\n-> f a b\n-> Encoding\nData.Aeson.Utils","kind":3,"label":"liftToEncoding2"},{"data":"liftToEncodingList2 module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Encoding)\n-> ([a] -> Encoding)\n-> (b -> Encoding)\n-> ([b] -> Encoding)\n-> [f a b]\n-> Encoding\nData.Aeson.Utils","kind":3,"label":"liftToEncodingList2"},{"data":"liftToJSON2 module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Value)\n-> ([a] -> Value)\n-> (b -> Value)\n-> ([b] -> Value)\n-> f a b\n-> Value\nData.Aeson.Utils","kind":3,"label":"liftToJSON2"},{"data":"liftToJSONList2 module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Value)\n-> ([a] -> Value)\n-> (b -> Value)\n-> ([b] -> Value)\n-> [f a b]\n-> Value\nData.Aeson.Utils","kind":3,"label":"liftToJSONList2"},{"data":"ToJSONKeyFunction module:Data.Aeson.Utils is:exact","detail":"Data.Aeson.Utils","kind":7,"label":"ToJSONKeyFunction"}],"id":767}
01:03:32 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:32 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:03:32 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:32 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:03:32 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:03:32 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:03:32 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25669}
01:03:32 INFO reader-main src/vim.rs:380 <= None {"id": 25669, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:03:32 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:03:32 INFO main src/languageclient.rs:1782 Texts equal. Skipping didChange.
01:03:32 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:03:32 INFO reader-main src/vim.rs:380 <= None {"id": 768, "jsonrpc": "2.0", "method": "LanguageClient_NCM2OnComplete", "params": {"languageId": "haskell", "ctx": {"filepath": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", "typed": "           (num |> AUtils.f", "scope_match": "haskell", "startccol": 27, "scope_level": 1, "word_pattern": "(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)", "time": 1.535782e9, "lnum": 44, "bufnr": 1, "changedtick": 4164, "manual": 0, "base": "f", "ccol": 28, "filetype": "haskell", "curpos": [0, 44, 28, 0, 28], "tick": [[0, 44, 28], 80], "early_cache": false, "context_id": 6922, "scope": "haskell", "matcher": {"name": "abbrfuzzy"}, "source": {"on_complete": "LanguageClient_NCM2OnComplete", "subscope_enable": 0, "early_cache": 0, "priority": 9, "scope": ["haskell"], "mark": "LC", "ready": 1, "enable": 1, "complete_pattern": ["\\."], "auto_popup": 1, "name": "LanguageClient_haskell"}, "bcol": 28, "match_end": 26}, "buftype": ""}}
01:03:32 INFO main src/languageclient.rs:2495 Begin LanguageClient_NCM2OnComplete
01:03:32 INFO main src/languageclient.rs:1296 Begin textDocument/completion
01:03:32 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename, Line, Character, Handle] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43), Number(27), Bool(false)]
01:03:32 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/completion","params":{"position":{"character":27,"line":43},"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}},"id":25670}
01:03:34 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"result":[{"kind":3,"data":"decodeFileStrict module:Data.Aeson.Utils is:exact","label":"decodeFileStrict","detail":"forall a. FromJSON a => FilePath -> IO (Maybe a)\nData.Aeson.Utils"},{"kind":3,"data":"decodeFileStrict' module:Data.Aeson.Utils is:exact","label":"decodeFileStrict'","detail":"forall a. FromJSON a => FilePath -> IO (Maybe a)\nData.Aeson.Utils"},{"kind":3,"data":"eitherDecodeFileStrict module:Data.Aeson.Utils is:exact","label":"eitherDecodeFileStrict","detail":"forall a. FromJSON a => FilePath -> IO (Either String a)\nData.Aeson.Utils"},{"kind":3,"data":"eitherDecodeFileStrict' module:Data.Aeson.Utils is:exact","label":"eitherDecodeFileStrict'","detail":"forall a. FromJSON a => FilePath -> IO (Either String a)\nData.Aeson.Utils"},{"kind":3,"data":"encodeFile module:Data.Aeson.Utils is:exact","label":"encodeFile","detail":"forall a. ToJSON a => FilePath -> a -> IO ()\nData.Aeson.Utils"},{"kind":3,"data":"unsafeToEncoding module:Data.Aeson.Utils is:exact","label":"unsafeToEncoding","detail":"forall a. Builder -> Encoding' a\nData.Aeson.Utils"},{"kind":3,"data":"foldable module:Data.Aeson.Utils is:exact","label":"foldable","detail":"forall (t :: * -> *) a. (Foldable t, ToJSON a) => t a -> Encoding\nData.Aeson.Utils"},{"kind":3,"data":"coerceFromJSONKeyFunction module:Data.Aeson.Utils is:exact","label":"coerceFromJSONKeyFunction","detail":"forall a b.\nCoercible a b =>\nFromJSONKeyFunction a -> FromJSONKeyFunction b\nData.Aeson.Utils"},{"kind":3,"data":"explicitParseField module:Data.Aeson.Utils is:exact","label":"explicitParseField","detail":"forall a. (Value -> Parser a) -> Object -> Text -> Parser a\nData.Aeson.Utils"},{"kind":3,"data":"explicitParseFieldMaybe module:Data.Aeson.Utils is:exact","label":"explicitParseFieldMaybe","detail":"forall a. (Value -> Parser a) -> Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils"},{"kind":3,"data":"explicitParseFieldMaybe' module:Data.Aeson.Utils is:exact","label":"explicitParseFieldMaybe'","detail":"forall a. (Value -> Parser a) -> Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils"},{"kind":3,"data":"fromJSON module:Data.Aeson.Utils is:exact","label":"fromJSON","detail":"forall a. FromJSON a => Value -> Result a\nData.Aeson.Utils"},{"kind":3,"data":"fromJSONKeyCoerce module:Data.Aeson.Utils is:exact","label":"fromJSONKeyCoerce","detail":"forall a. Coercible Text a => FromJSONKeyFunction a\nData.Aeson.Utils"},{"kind":3,"data":"genericLiftParseJSON module:Data.Aeson.Utils is:exact","label":"genericLiftParseJSON","detail":"forall (f :: * -> *) a.\n(Generic1 f, GFromJSON One (Rep1 f)) =>\nOptions\n-> (Value -> Parser a)\n-> (Value -> Parser [a])\n-> Value\n-> Parser (f a)\nData.Aeson.Utils"},{"kind":3,"data":"mapFromJSONKeyFunction module:Data.Aeson.Utils is:exact","label":"mapFromJSONKeyFunction","detail":"forall a b.\n(a -> b) -> FromJSONKeyFunction a -> FromJSONKeyFunction b\nData.Aeson.Utils"},{"kind":3,"data":"parseField module:Data.Aeson.Utils is:exact","label":"parseField","detail":"forall a. FromJSON a => Object -> Text -> Parser a\nData.Aeson.Utils"},{"kind":3,"data":"parseFieldMaybe module:Data.Aeson.Utils is:exact","label":"parseFieldMaybe","detail":"forall a. FromJSON a => Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils"},{"kind":3,"data":"parseFieldMaybe' module:Data.Aeson.Utils is:exact","label":"parseFieldMaybe'","detail":"forall a. FromJSON a => Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils"},{"kind":3,"data":"withScientific module:Data.Aeson.Utils is:exact","label":"withScientific","detail":"forall a. String -> (Scientific -> Parser a) -> Value -> Parser a\nData.Aeson.Utils"},{"kind":3,"data":"defaultOptions module:Data.Aeson.Utils is:exact","label":"defaultOptions","detail":"Options\nData.Aeson.Utils"},{"kind":3,"data":"defaultTaggedObject module:Data.Aeson.Utils is:exact","label":"defaultTaggedObject","detail":"SumEncoding\nData.Aeson.Utils"},{"kind":3,"data":"modifyFailure module:Data.Aeson.Utils is:exact","label":"modifyFailure","detail":"forall a. (String -> String) -> Parser a -> Parser a\nData.Aeson.Utils"},{"kind":3,"data":"contramapToJSONKeyFunction module:Data.Aeson.Utils is:exact","label":"contramapToJSONKeyFunction","detail":"forall b a. (b -> a) -> ToJSONKeyFunction a -> ToJSONKeyFunction b\nData.Aeson.Utils"},{"kind":3,"data":"genericLiftToEncoding module:Data.Aeson.Utils is:exact","label":"genericLiftToEncoding","detail":"forall (f :: * -> *) a.\n(Generic1 f, GToJSON Encoding One (Rep1 f)) =>\nOptions -> (a -> Encoding) -> ([a] -> Encoding) -> f a -> Encoding\nData.Aeson.Utils"},{"kind":3,"data":"genericLiftToJSON module:Data.Aeson.Utils is:exact","label":"genericLiftToJSON","detail":"forall (f :: * -> *) a.\n(Generic1 f, GToJSON Value One (Rep1 f)) =>\nOptions -> (a -> Value) -> ([a] -> Value) -> f a -> Value\nData.Aeson.Utils"},{"kind":3,"data":"floatingOrInteger module:Data.Aeson.Utils is:exact","label":"floatingOrInteger","detail":"forall r i. (RealFloat r, Integral i) => Scientific -> Either r i\nData.Aeson.Utils"},{"kind":3,"data":"fromFloatDigits module:Data.Aeson.Utils is:exact","label":"fromFloatDigits","detail":"forall a. RealFloat a => a -> Scientific\nData.Aeson.Utils"},{"kind":3,"data":"fromEncoding module:Data.Aeson.Utils is:exact","label":"fromEncoding","detail":"forall tag. Encoding' tag -> Builder\nData.Aeson.Utils"},{"kind":7,"data":"FromArgs module:Data.Aeson.Utils is:exact","label":"FromArgs","detail":"Data.Aeson.Utils"},{"kind":4,"data":"From1Args module:Data.Aeson.Utils is:exact","label":"From1Args","detail":"forall a.\n(Value -> Parser a) -> (Value -> Parser [a]) -> FromArgs One a\nData.Aeson.Utils"},{"kind":4,"data":"NoFromArgs module:Data.Aeson.Utils is:exact","label":"NoFromArgs","detail":"forall a. FromArgs Zero a\nData.Aeson.Utils"},{"kind":7,"data":"FromJSON module:Data.Aeson.Utils is:exact","label":"FromJSON","detail":"Data.Aeson.Utils"},{"kind":7,"data":"FromJSON1 module:Data.Aeson.Utils is:exact","label":"FromJSON1","detail":"Data.Aeson.Utils"},{"kind":3,"data":"liftParseJSON module:Data.Aeson.Utils is:exact","label":"liftParseJSON","detail":"forall (f :: * -> *).\nFromJSON1 f =>\nforall a.\n(Value -> Parser a)\n-> (Value -> Parser [a]) -> Value -> Parser (f a)\nData.Aeson.Utils"},{"kind":3,"data":"liftParseJSONList module:Data.Aeson.Utils is:exact","label":"liftParseJSONList","detail":"forall (f :: * -> *).\nFromJSON1 f =>\nforall a.\n(Value -> Parser a)\n-> (Value -> Parser [a]) -> Value -> Parser [f a]\nData.Aeson.Utils"},{"kind":7,"data":"FromJSON2 module:Data.Aeson.Utils is:exact","label":"FromJSON2","detail":"Data.Aeson.Utils"},{"kind":3,"data":"liftParseJSON2 module:Data.Aeson.Utils is:exact","label":"liftParseJSON2","detail":"forall (f :: * -> * -> *).\nFromJSON2 f =>\nforall a b.\n(Value -> Parser a)\n-> (Value -> Parser [a])\n-> (Value -> Parser b)\n-> (Value -> Parser [b])\n-> Value\n-> Parser (f a b)\nData.Aeson.Utils"},{"kind":3,"data":"liftParseJSONList2 module:Data.Aeson.Utils is:exact","label":"liftParseJSONList2","detail":"forall (f :: * -> * -> *).\nFromJSON2 f =>\nforall a b.\n(Value -> Parser a)\n-> (Value -> Parser [a])\n-> (Value -> Parser b)\n-> (Value -> Parser [b])\n-> Value\n-> Parser [f a b]\nData.Aeson.Utils"},{"kind":7,"data":"FromJSONKey module:Data.Aeson.Utils is:exact","label":"FromJSONKey","detail":"Data.Aeson.Utils"},{"kind":3,"data":"fromJSONKey module:Data.Aeson.Utils is:exact","label":"fromJSONKey","detail":"forall a. FromJSONKey a => FromJSONKeyFunction a\nData.Aeson.Utils"},{"kind":3,"data":"fromJSONKeyList module:Data.Aeson.Utils is:exact","label":"fromJSONKeyList","detail":"forall a. FromJSONKey a => FromJSONKeyFunction [a]\nData.Aeson.Utils"},{"kind":7,"data":"FromJSONKeyFunction module:Data.Aeson.Utils is:exact","label":"FromJSONKeyFunction","detail":"Data.Aeson.Utils"},{"kind":4,"data":"FromJSONKeyCoerce module:Data.Aeson.Utils is:exact","label":"FromJSONKeyCoerce","detail":"forall a. CoerceText a -> FromJSONKeyFunction a\nData.Aeson.Utils"},{"kind":4,"data":"FromJSONKeyText module:Data.Aeson.Utils is:exact","label":"FromJSONKeyText","detail":"forall a. (Text -> a) -> FromJSONKeyFunction a\nData.Aeson.Utils"},{"kind":4,"data":"FromJSONKeyTextParser module:Data.Aeson.Utils is:exact","label":"FromJSONKeyTextParser","detail":"forall a. (Text -> Parser a) -> FromJSONKeyFunction a\nData.Aeson.Utils"},{"kind":4,"data":"FromJSONKeyValue module:Data.Aeson.Utils is:exact","label":"FromJSONKeyValue","detail":"forall a. (Value -> Parser a) -> FromJSONKeyFunction a\nData.Aeson.Utils"},{"kind":7,"data":"GFromJSON module:Data.Aeson.Utils is:exact","label":"GFromJSON","detail":"Data.Aeson.Utils"},{"kind":3,"data":"fromDotNetTime module:Data.Aeson.Utils is:exact","label":"fromDotNetTime","detail":"DotNetTime -> UTCTime\nData.Aeson.Utils"},{"kind":3,"data":"constructorTagModifier module:Data.Aeson.Utils is:exact","label":"constructorTagModifier","detail":"Options -> String -> String\nData.Aeson.Utils"},{"kind":3,"data":"fieldLabelModifier module:Data.Aeson.Utils is:exact","label":"fieldLabelModifier","detail":"Options -> String -> String\nData.Aeson.Utils"},{"kind":3,"data":"omitNothingFields module:Data.Aeson.Utils is:exact","label":"omitNothingFields","detail":"Options -> Bool\nData.Aeson.Utils"},{"kind":4,"data":"ObjectWithSingleField module:Data.Aeson.Utils is:exact","label":"ObjectWithSingleField","detail":"SumEncoding\nData.Aeson.Utils"},{"kind":3,"data":"contentsFieldName module:Data.Aeson.Utils is:exact","label":"contentsFieldName","detail":"SumEncoding -> String\nData.Aeson.Utils"},{"kind":3,"data":"tagFieldName module:Data.Aeson.Utils is:exact","label":"tagFieldName","detail":"SumEncoding -> String\nData.Aeson.Utils"},{"kind":3,"data":"liftToEncoding module:Data.Aeson.Utils is:exact","label":"liftToEncoding","detail":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Encoding) -> ([a] -> Encoding) -> f a -> Encoding\nData.Aeson.Utils"},{"kind":3,"data":"liftToEncodingList module:Data.Aeson.Utils is:exact","label":"liftToEncodingList","detail":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Encoding) -> ([a] -> Encoding) -> [f a] -> Encoding\nData.Aeson.Utils"},{"kind":3,"data":"liftToJSON module:Data.Aeson.Utils is:exact","label":"liftToJSON","detail":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Value) -> ([a] -> Value) -> f a -> Value\nData.Aeson.Utils"},{"kind":3,"data":"liftToJSONList module:Data.Aeson.Utils is:exact","label":"liftToJSONList","detail":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Value) -> ([a] -> Value) -> [f a] -> Value\nData.Aeson.Utils"},{"kind":3,"data":"liftToEncoding2 module:Data.Aeson.Utils is:exact","label":"liftToEncoding2","detail":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Encoding)\n-> ([a] -> Encoding)\n-> (b -> Encoding)\n-> ([b] -> Encoding)\n-> f a b\n-> Encoding\nData.Aeson.Utils"},{"kind":3,"data":"liftToEncodingList2 module:Data.Aeson.Utils is:exact","label":"liftToEncodingList2","detail":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Encoding)\n-> ([a] -> Encoding)\n-> (b -> Encoding)\n-> ([b] -> Encoding)\n-> [f a b]\n-> Encoding\nData.Aeson.Utils"},{"kind":3,"data":"liftToJSON2 module:Data.Aeson.Utils is:exact","label":"liftToJSON2","detail":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Value)\n-> ([a] -> Value)\n-> (b -> Value)\n-> ([b] -> Value)\n-> f a b\n-> Value\nData.Aeson.Utils"},{"kind":3,"data":"liftToJSONList2 module:Data.Aeson.Utils is:exact","label":"liftToJSONList2","detail":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Value)\n-> ([a] -> Value)\n-> (b -> Value)\n-> ([b] -> Value)\n-> [f a b]\n-> Value\nData.Aeson.Utils"},{"kind":7,"data":"ToJSONKeyFunction module:Data.Aeson.Utils is:exact","label":"ToJSONKeyFunction","detail":"Data.Aeson.Utils"}],"jsonrpc":"2.0","id":25670}
01:03:34 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"ncm2#complete","params":[{"base":"f","bcol":28,"bufnr":1,"ccol":28,"changedtick":4164,"context_id":6922,"curpos":[0,44,28,0,28],"early_cache":false,"filepath":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","filetype":"haskell","lnum":44,"manual":0,"match_end":26,"matcher":{"name":"abbrfuzzy"},"scope":"haskell","scope_level":1,"scope_match":"haskell","source":{"auto_popup":1,"complete_pattern":["\\."],"early_cache":0,"enable":1,"mark":"LC","name":"LanguageClient_haskell","on_complete":"LanguageClient_NCM2OnComplete","priority":9,"ready":1,"scope":["haskell"],"subscope_enable":0},"startccol":27,"tick":[[0,44,28],80],"time":1535782000.0,"typed":"           (num |> AUtils.f","word_pattern":"(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)"},27,[{"abbr":"decodeFileStrict","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. FromJSON a => FilePath -> IO (Maybe a)\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"decodeFileStrict\",\"kind\":3,\"detail\":\"forall a. FromJSON a => FilePath -> IO (Maybe a)\\nData.Aeson.Utils\",\"data\":\"decodeFileStrict module:Data.Aeson.Utils is:exact\"}}","word":"decodeFileStrict"},{"abbr":"decodeFileStrict'","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. FromJSON a => FilePath -> IO (Maybe a)\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"decodeFileStrict'\",\"kind\":3,\"detail\":\"forall a. FromJSON a => FilePath -> IO (Maybe a)\\nData.Aeson.Utils\",\"data\":\"decodeFileStrict' module:Data.Aeson.Utils is:exact\"}}","word":"decodeFileStrict'"},{"abbr":"eitherDecodeFileStrict","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. FromJSON a => FilePath -> IO (Either String a)\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"eitherDecodeFileStrict\",\"kind\":3,\"detail\":\"forall a. FromJSON a => FilePath -> IO (Either String a)\\nData.Aeson.Utils\",\"data\":\"eitherDecodeFileStrict module:Data.Aeson.Utils is:exact\"}}","word":"eitherDecodeFileStrict"},{"abbr":"eitherDecodeFileStrict'","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. FromJSON a => FilePath -> IO (Either String a)\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"eitherDecodeFileStrict'\",\"kind\":3,\"detail\":\"forall a. FromJSON a => FilePath -> IO (Either String a)\\nData.Aeson.Utils\",\"data\":\"eitherDecodeFileStrict' module:Data.Aeson.Utils is:exact\"}}","word":"eitherDecodeFileStrict'"},{"abbr":"encodeFile","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. ToJSON a => FilePath -> a -> IO ()\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"encodeFile\",\"kind\":3,\"detail\":\"forall a. ToJSON a => FilePath -> a -> IO ()\\nData.Aeson.Utils\",\"data\":\"encodeFile module:Data.Aeson.Utils is:exact\"}}","word":"encodeFile"},{"abbr":"unsafeToEncoding","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. Builder -> Encoding' a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"unsafeToEncoding\",\"kind\":3,\"detail\":\"forall a. Builder -> Encoding' a\\nData.Aeson.Utils\",\"data\":\"unsafeToEncoding module:Data.Aeson.Utils is:exact\"}}","word":"unsafeToEncoding"},{"abbr":"foldable","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (t :: * -> *) a. (Foldable t, ToJSON a) => t a -> Encoding\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"foldable\",\"kind\":3,\"detail\":\"forall (t :: * -> *) a. (Foldable t, ToJSON a) => t a -> Encoding\\nData.Aeson.Utils\",\"data\":\"foldable module:Data.Aeson.Utils is:exact\"}}","word":"foldable"},{"abbr":"coerceFromJSONKeyFunction","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a b.\nCoercible a b =>\nFromJSONKeyFunction a -> FromJSONKeyFunction b\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"coerceFromJSONKeyFunction\",\"kind\":3,\"detail\":\"forall a b.\\nCoercible a b =>\\nFromJSONKeyFunction a -> FromJSONKeyFunction b\\nData.Aeson.Utils\",\"data\":\"coerceFromJSONKeyFunction module:Data.Aeson.Utils is:exact\"}}","word":"coerceFromJSONKeyFunction"},{"abbr":"explicitParseField","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. (Value -> Parser a) -> Object -> Text -> Parser a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"explicitParseField\",\"kind\":3,\"detail\":\"forall a. (Value -> Parser a) -> Object -> Text -> Parser a\\nData.Aeson.Utils\",\"data\":\"explicitParseField module:Data.Aeson.Utils is:exact\"}}","word":"explicitParseField"},{"abbr":"explicitParseFieldMaybe","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. (Value -> Parser a) -> Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"explicitParseFieldMaybe\",\"kind\":3,\"detail\":\"forall a. (Value -> Parser a) -> Object -> Text -> Parser (Maybe a)\\nData.Aeson.Utils\",\"data\":\"explicitParseFieldMaybe module:Data.Aeson.Utils is:exact\"}}","word":"explicitParseFieldMaybe"},{"abbr":"explicitParseFieldMaybe'","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. (Value -> Parser a) -> Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"explicitParseFieldMaybe'\",\"kind\":3,\"detail\":\"forall a. (Value -> Parser a) -> Object -> Text -> Parser (Maybe a)\\nData.Aeson.Utils\",\"data\":\"explicitParseFieldMaybe' module:Data.Aeson.Utils is:exact\"}}","word":"explicitParseFieldMaybe'"},{"abbr":"fromJSON","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. FromJSON a => Value -> Result a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"fromJSON\",\"kind\":3,\"detail\":\"forall a. FromJSON a => Value -> Result a\\nData.Aeson.Utils\",\"data\":\"fromJSON module:Data.Aeson.Utils is:exact\"}}","word":"fromJSON"},{"abbr":"fromJSONKeyCoerce","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. Coercible Text a => FromJSONKeyFunction a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"fromJSONKeyCoerce\",\"kind\":3,\"detail\":\"forall a. Coercible Text a => FromJSONKeyFunction a\\nData.Aeson.Utils\",\"data\":\"fromJSONKeyCoerce module:Data.Aeson.Utils is:exact\"}}","word":"fromJSONKeyCoerce"},{"abbr":"genericLiftParseJSON","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> *) a.\n(Generic1 f, GFromJSON One (Rep1 f)) =>\nOptions\n-> (Value -> Parser a)\n-> (Value -> Parser [a])\n-> Value\n-> Parser (f a)\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"genericLiftParseJSON\",\"kind\":3,\"detail\":\"forall (f :: * -> *) a.\\n(Generic1 f, GFromJSON One (Rep1 f)) =>\\nOptions\\n-> (Value -> Parser a)\\n-> (Value -> Parser [a])\\n-> Value\\n-> Parser (f a)\\nData.Aeson.Utils\",\"data\":\"genericLiftParseJSON module:Data.Aeson.Utils is:exact\"}}","word":"genericLiftParseJSON"},{"abbr":"mapFromJSONKeyFunction","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a b.\n(a -> b) -> FromJSONKeyFunction a -> FromJSONKeyFunction b\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"mapFromJSONKeyFunction\",\"kind\":3,\"detail\":\"forall a b.\\n(a -> b) -> FromJSONKeyFunction a -> FromJSONKeyFunction b\\nData.Aeson.Utils\",\"data\":\"mapFromJSONKeyFunction module:Data.Aeson.Utils is:exact\"}}","word":"mapFromJSONKeyFunction"},{"abbr":"parseField","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. FromJSON a => Object -> Text -> Parser a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"parseField\",\"kind\":3,\"detail\":\"forall a. FromJSON a => Object -> Text -> Parser a\\nData.Aeson.Utils\",\"data\":\"parseField module:Data.Aeson.Utils is:exact\"}}","word":"parseField"},{"abbr":"parseFieldMaybe","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. FromJSON a => Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"parseFieldMaybe\",\"kind\":3,\"detail\":\"forall a. FromJSON a => Object -> Text -> Parser (Maybe a)\\nData.Aeson.Utils\",\"data\":\"parseFieldMaybe module:Data.Aeson.Utils is:exact\"}}","word":"parseFieldMaybe"},{"abbr":"parseFieldMaybe'","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. FromJSON a => Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"parseFieldMaybe'\",\"kind\":3,\"detail\":\"forall a. FromJSON a => Object -> Text -> Parser (Maybe a)\\nData.Aeson.Utils\",\"data\":\"parseFieldMaybe' module:Data.Aeson.Utils is:exact\"}}","word":"parseFieldMaybe'"},{"abbr":"withScientific","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. String -> (Scientific -> Parser a) -> Value -> Parser a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"withScientific\",\"kind\":3,\"detail\":\"forall a. String -> (Scientific -> Parser a) -> Value -> Parser a\\nData.Aeson.Utils\",\"data\":\"withScientific module:Data.Aeson.Utils is:exact\"}}","word":"withScientific"},{"abbr":"defaultOptions","dup":1,"icase":1,"info":"","kind":"Function","menu":"Options\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"defaultOptions\",\"kind\":3,\"detail\":\"Options\\nData.Aeson.Utils\",\"data\":\"defaultOptions module:Data.Aeson.Utils is:exact\"}}","word":"defaultOptions"},{"abbr":"defaultTaggedObject","dup":1,"icase":1,"info":"","kind":"Function","menu":"SumEncoding\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"defaultTaggedObject\",\"kind\":3,\"detail\":\"SumEncoding\\nData.Aeson.Utils\",\"data\":\"defaultTaggedObject module:Data.Aeson.Utils is:exact\"}}","word":"defaultTaggedObject"},{"abbr":"modifyFailure","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. (String -> String) -> Parser a -> Parser a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"modifyFailure\",\"kind\":3,\"detail\":\"forall a. (String -> String) -> Parser a -> Parser a\\nData.Aeson.Utils\",\"data\":\"modifyFailure module:Data.Aeson.Utils is:exact\"}}","word":"modifyFailure"},{"abbr":"contramapToJSONKeyFunction","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall b a. (b -> a) -> ToJSONKeyFunction a -> ToJSONKeyFunction b\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"contramapToJSONKeyFunction\",\"kind\":3,\"detail\":\"forall b a. (b -> a) -> ToJSONKeyFunction a -> ToJSONKeyFunction b\\nData.Aeson.Utils\",\"data\":\"contramapToJSONKeyFunction module:Data.Aeson.Utils is:exact\"}}","word":"contramapToJSONKeyFunction"},{"abbr":"genericLiftToEncoding","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> *) a.\n(Generic1 f, GToJSON Encoding One (Rep1 f)) =>\nOptions -> (a -> Encoding) -> ([a] -> Encoding) -> f a -> Encoding\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"genericLiftToEncoding\",\"kind\":3,\"detail\":\"forall (f :: * -> *) a.\\n(Generic1 f, GToJSON Encoding One (Rep1 f)) =>\\nOptions -> (a -> Encoding) -> ([a] -> Encoding) -> f a -> Encoding\\nData.Aeson.Utils\",\"data\":\"genericLiftToEncoding module:Data.Aeson.Utils is:exact\"}}","word":"genericLiftToEncoding"},{"abbr":"genericLiftToJSON","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> *) a.\n(Generic1 f, GToJSON Value One (Rep1 f)) =>\nOptions -> (a -> Value) -> ([a] -> Value) -> f a -> Value\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"genericLiftToJSON\",\"kind\":3,\"detail\":\"forall (f :: * -> *) a.\\n(Generic1 f, GToJSON Value One (Rep1 f)) =>\\nOptions -> (a -> Value) -> ([a] -> Value) -> f a -> Value\\nData.Aeson.Utils\",\"data\":\"genericLiftToJSON module:Data.Aeson.Utils is:exact\"}}","word":"genericLiftToJSON"},{"abbr":"floatingOrInteger","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall r i. (RealFloat r, Integral i) => Scientific -> Either r i\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"floatingOrInteger\",\"kind\":3,\"detail\":\"forall r i. (RealFloat r, Integral i) => Scientific -> Either r i\\nData.Aeson.Utils\",\"data\":\"floatingOrInteger module:Data.Aeson.Utils is:exact\"}}","word":"floatingOrInteger"},{"abbr":"fromFloatDigits","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. RealFloat a => a -> Scientific\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"fromFloatDigits\",\"kind\":3,\"detail\":\"forall a. RealFloat a => a -> Scientific\\nData.Aeson.Utils\",\"data\":\"fromFloatDigits module:Data.Aeson.Utils is:exact\"}}","word":"fromFloatDigits"},{"abbr":"fromEncoding","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall tag. Encoding' tag -> Builder\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"fromEncoding\",\"kind\":3,\"detail\":\"forall tag. Encoding' tag -> Builder\\nData.Aeson.Utils\",\"data\":\"fromEncoding module:Data.Aeson.Utils is:exact\"}}","word":"fromEncoding"},{"abbr":"FromArgs","dup":1,"icase":1,"info":"","kind":"Class","menu":"Data.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"FromArgs\",\"kind\":7,\"detail\":\"Data.Aeson.Utils\",\"data\":\"FromArgs module:Data.Aeson.Utils is:exact\"}}","word":"FromArgs"},{"abbr":"From1Args","dup":1,"icase":1,"info":"","kind":"Constructor","menu":"forall a.\n(Value -> Parser a) -> (Value -> Parser [a]) -> FromArgs One a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"From1Args\",\"kind\":4,\"detail\":\"forall a.\\n(Value -> Parser a) -> (Value -> Parser [a]) -> FromArgs One a\\nData.Aeson.Utils\",\"data\":\"From1Args module:Data.Aeson.Utils is:exact\"}}","word":"From1Args"},{"abbr":"NoFromArgs","dup":1,"icase":1,"info":"","kind":"Constructor","menu":"forall a. FromArgs Zero a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"NoFromArgs\",\"kind\":4,\"detail\":\"forall a. FromArgs Zero a\\nData.Aeson.Utils\",\"data\":\"NoFromArgs module:Data.Aeson.Utils is:exact\"}}","word":"NoFromArgs"},{"abbr":"FromJSON","dup":1,"icase":1,"info":"","kind":"Class","menu":"Data.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"FromJSON\",\"kind\":7,\"detail\":\"Data.Aeson.Utils\",\"data\":\"FromJSON module:Data.Aeson.Utils is:exact\"}}","word":"FromJSON"},{"abbr":"FromJSON1","dup":1,"icase":1,"info":"","kind":"Class","menu":"Data.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"FromJSON1\",\"kind\":7,\"detail\":\"Data.Aeson.Utils\",\"data\":\"FromJSON1 module:Data.Aeson.Utils is:exact\"}}","word":"FromJSON1"},{"abbr":"liftParseJSON","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> *).\nFromJSON1 f =>\nforall a.\n(Value -> Parser a)\n-> (Value -> Parser [a]) -> Value -> Parser (f a)\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftParseJSON\",\"kind\":3,\"detail\":\"forall (f :: * -> *).\\nFromJSON1 f =>\\nforall a.\\n(Value -> Parser a)\\n-> (Value -> Parser [a]) -> Value -> Parser (f a)\\nData.Aeson.Utils\",\"data\":\"liftParseJSON module:Data.Aeson.Utils is:exact\"}}","word":"liftParseJSON"},{"abbr":"liftParseJSONList","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> *).\nFromJSON1 f =>\nforall a.\n(Value -> Parser a)\n-> (Value -> Parser [a]) -> Value -> Parser [f a]\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftParseJSONList\",\"kind\":3,\"detail\":\"forall (f :: * -> *).\\nFromJSON1 f =>\\nforall a.\\n(Value -> Parser a)\\n-> (Value -> Parser [a]) -> Value -> Parser [f a]\\nData.Aeson.Utils\",\"data\":\"liftParseJSONList module:Data.Aeson.Utils is:exact\"}}","word":"liftParseJSONList"},{"abbr":"FromJSON2","dup":1,"icase":1,"info":"","kind":"Class","menu":"Data.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"FromJSON2\",\"kind\":7,\"detail\":\"Data.Aeson.Utils\",\"data\":\"FromJSON2 module:Data.Aeson.Utils is:exact\"}}","word":"FromJSON2"},{"abbr":"liftParseJSON2","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> * -> *).\nFromJSON2 f =>\nforall a b.\n(Value -> Parser a)\n-> (Value -> Parser [a])\n-> (Value -> Parser b)\n-> (Value -> Parser [b])\n-> Value\n-> Parser (f a b)\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftParseJSON2\",\"kind\":3,\"detail\":\"forall (f :: * -> * -> *).\\nFromJSON2 f =>\\nforall a b.\\n(Value -> Parser a)\\n-> (Value -> Parser [a])\\n-> (Value -> Parser b)\\n-> (Value -> Parser [b])\\n-> Value\\n-> Parser (f a b)\\nData.Aeson.Utils\",\"data\":\"liftParseJSON2 module:Data.Aeson.Utils is:exact\"}}","word":"liftParseJSON2"},{"abbr":"liftParseJSONList2","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> * -> *).\nFromJSON2 f =>\nforall a b.\n(Value -> Parser a)\n-> (Value -> Parser [a])\n-> (Value -> Parser b)\n-> (Value -> Parser [b])\n-> Value\n-> Parser [f a b]\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftParseJSONList2\",\"kind\":3,\"detail\":\"forall (f :: * -> * -> *).\\nFromJSON2 f =>\\nforall a b.\\n(Value -> Parser a)\\n-> (Value -> Parser [a])\\n-> (Value -> Parser b)\\n-> (Value -> Parser [b])\\n-> Value\\n-> Parser [f a b]\\nData.Aeson.Utils\",\"data\":\"liftParseJSONList2 module:Data.Aeson.Utils is:exact\"}}","word":"liftParseJSONList2"},{"abbr":"FromJSONKey","dup":1,"icase":1,"info":"","kind":"Class","menu":"Data.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"FromJSONKey\",\"kind\":7,\"detail\":\"Data.Aeson.Utils\",\"data\":\"FromJSONKey module:Data.Aeson.Utils is:exact\"}}","word":"FromJSONKey"},{"abbr":"fromJSONKey","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. FromJSONKey a => FromJSONKeyFunction a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"fromJSONKey\",\"kind\":3,\"detail\":\"forall a. FromJSONKey a => FromJSONKeyFunction a\\nData.Aeson.Utils\",\"data\":\"fromJSONKey module:Data.Aeson.Utils is:exact\"}}","word":"fromJSONKey"},{"abbr":"fromJSONKeyList","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall a. FromJSONKey a => FromJSONKeyFunction [a]\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"fromJSONKeyList\",\"kind\":3,\"detail\":\"forall a. FromJSONKey a => FromJSONKeyFunction [a]\\nData.Aeson.Utils\",\"data\":\"fromJSONKeyList module:Data.Aeson.Utils is:exact\"}}","word":"fromJSONKeyList"},{"abbr":"FromJSONKeyFunction","dup":1,"icase":1,"info":"","kind":"Class","menu":"Data.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"FromJSONKeyFunction\",\"kind\":7,\"detail\":\"Data.Aeson.Utils\",\"data\":\"FromJSONKeyFunction module:Data.Aeson.Utils is:exact\"}}","word":"FromJSONKeyFunction"},{"abbr":"FromJSONKeyCoerce","dup":1,"icase":1,"info":"","kind":"Constructor","menu":"forall a. CoerceText a -> FromJSONKeyFunction a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"FromJSONKeyCoerce\",\"kind\":4,\"detail\":\"forall a. CoerceText a -> FromJSONKeyFunction a\\nData.Aeson.Utils\",\"data\":\"FromJSONKeyCoerce module:Data.Aeson.Utils is:exact\"}}","word":"FromJSONKeyCoerce"},{"abbr":"FromJSONKeyText","dup":1,"icase":1,"info":"","kind":"Constructor","menu":"forall a. (Text -> a) -> FromJSONKeyFunction a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"FromJSONKeyText\",\"kind\":4,\"detail\":\"forall a. (Text -> a) -> FromJSONKeyFunction a\\nData.Aeson.Utils\",\"data\":\"FromJSONKeyText module:Data.Aeson.Utils is:exact\"}}","word":"FromJSONKeyText"},{"abbr":"FromJSONKeyTextParser","dup":1,"icase":1,"info":"","kind":"Constructor","menu":"forall a. (Text -> Parser a) -> FromJSONKeyFunction a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"FromJSONKeyTextParser\",\"kind\":4,\"detail\":\"forall a. (Text -> Parser a) -> FromJSONKeyFunction a\\nData.Aeson.Utils\",\"data\":\"FromJSONKeyTextParser module:Data.Aeson.Utils is:exact\"}}","word":"FromJSONKeyTextParser"},{"abbr":"FromJSONKeyValue","dup":1,"icase":1,"info":"","kind":"Constructor","menu":"forall a. (Value -> Parser a) -> FromJSONKeyFunction a\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"FromJSONKeyValue\",\"kind\":4,\"detail\":\"forall a. (Value -> Parser a) -> FromJSONKeyFunction a\\nData.Aeson.Utils\",\"data\":\"FromJSONKeyValue module:Data.Aeson.Utils is:exact\"}}","word":"FromJSONKeyValue"},{"abbr":"GFromJSON","dup":1,"icase":1,"info":"","kind":"Class","menu":"Data.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"GFromJSON\",\"kind\":7,\"detail\":\"Data.Aeson.Utils\",\"data\":\"GFromJSON module:Data.Aeson.Utils is:exact\"}}","word":"GFromJSON"},{"abbr":"fromDotNetTime","dup":1,"icase":1,"info":"","kind":"Function","menu":"DotNetTime -> UTCTime\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"fromDotNetTime\",\"kind\":3,\"detail\":\"DotNetTime -> UTCTime\\nData.Aeson.Utils\",\"data\":\"fromDotNetTime module:Data.Aeson.Utils is:exact\"}}","word":"fromDotNetTime"},{"abbr":"constructorTagModifier","dup":1,"icase":1,"info":"","kind":"Function","menu":"Options -> String -> String\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"constructorTagModifier\",\"kind\":3,\"detail\":\"Options -> String -> String\\nData.Aeson.Utils\",\"data\":\"constructorTagModifier module:Data.Aeson.Utils is:exact\"}}","word":"constructorTagModifier"},{"abbr":"fieldLabelModifier","dup":1,"icase":1,"info":"","kind":"Function","menu":"Options -> String -> String\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"fieldLabelModifier\",\"kind\":3,\"detail\":\"Options -> String -> String\\nData.Aeson.Utils\",\"data\":\"fieldLabelModifier module:Data.Aeson.Utils is:exact\"}}","word":"fieldLabelModifier"},{"abbr":"omitNothingFields","dup":1,"icase":1,"info":"","kind":"Function","menu":"Options -> Bool\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"omitNothingFields\",\"kind\":3,\"detail\":\"Options -> Bool\\nData.Aeson.Utils\",\"data\":\"omitNothingFields module:Data.Aeson.Utils is:exact\"}}","word":"omitNothingFields"},{"abbr":"ObjectWithSingleField","dup":1,"icase":1,"info":"","kind":"Constructor","menu":"SumEncoding\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"ObjectWithSingleField\",\"kind\":4,\"detail\":\"SumEncoding\\nData.Aeson.Utils\",\"data\":\"ObjectWithSingleField module:Data.Aeson.Utils is:exact\"}}","word":"ObjectWithSingleField"},{"abbr":"contentsFieldName","dup":1,"icase":1,"info":"","kind":"Function","menu":"SumEncoding -> String\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"contentsFieldName\",\"kind\":3,\"detail\":\"SumEncoding -> String\\nData.Aeson.Utils\",\"data\":\"contentsFieldName module:Data.Aeson.Utils is:exact\"}}","word":"contentsFieldName"},{"abbr":"tagFieldName","dup":1,"icase":1,"info":"","kind":"Function","menu":"SumEncoding -> String\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"tagFieldName\",\"kind\":3,\"detail\":\"SumEncoding -> String\\nData.Aeson.Utils\",\"data\":\"tagFieldName module:Data.Aeson.Utils is:exact\"}}","word":"tagFieldName"},{"abbr":"liftToEncoding","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Encoding) -> ([a] -> Encoding) -> f a -> Encoding\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftToEncoding\",\"kind\":3,\"detail\":\"forall (f :: * -> *).\\nToJSON1 f =>\\nforall a. (a -> Encoding) -> ([a] -> Encoding) -> f a -> Encoding\\nData.Aeson.Utils\",\"data\":\"liftToEncoding module:Data.Aeson.Utils is:exact\"}}","word":"liftToEncoding"},{"abbr":"liftToEncodingList","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Encoding) -> ([a] -> Encoding) -> [f a] -> Encoding\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftToEncodingList\",\"kind\":3,\"detail\":\"forall (f :: * -> *).\\nToJSON1 f =>\\nforall a. (a -> Encoding) -> ([a] -> Encoding) -> [f a] -> Encoding\\nData.Aeson.Utils\",\"data\":\"liftToEncodingList module:Data.Aeson.Utils is:exact\"}}","word":"liftToEncodingList"},{"abbr":"liftToJSON","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Value) -> ([a] -> Value) -> f a -> Value\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftToJSON\",\"kind\":3,\"detail\":\"forall (f :: * -> *).\\nToJSON1 f =>\\nforall a. (a -> Value) -> ([a] -> Value) -> f a -> Value\\nData.Aeson.Utils\",\"data\":\"liftToJSON module:Data.Aeson.Utils is:exact\"}}","word":"liftToJSON"},{"abbr":"liftToJSONList","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Value) -> ([a] -> Value) -> [f a] -> Value\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftToJSONList\",\"kind\":3,\"detail\":\"forall (f :: * -> *).\\nToJSON1 f =>\\nforall a. (a -> Value) -> ([a] -> Value) -> [f a] -> Value\\nData.Aeson.Utils\",\"data\":\"liftToJSONList module:Data.Aeson.Utils is:exact\"}}","word":"liftToJSONList"},{"abbr":"liftToEncoding2","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Encoding)\n-> ([a] -> Encoding)\n-> (b -> Encoding)\n-> ([b] -> Encoding)\n-> f a b\n-> Encoding\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftToEncoding2\",\"kind\":3,\"detail\":\"forall (f :: * -> * -> *).\\nToJSON2 f =>\\nforall a b.\\n(a -> Encoding)\\n-> ([a] -> Encoding)\\n-> (b -> Encoding)\\n-> ([b] -> Encoding)\\n-> f a b\\n-> Encoding\\nData.Aeson.Utils\",\"data\":\"liftToEncoding2 module:Data.Aeson.Utils is:exact\"}}","word":"liftToEncoding2"},{"abbr":"liftToEncodingList2","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Encoding)\n-> ([a] -> Encoding)\n-> (b -> Encoding)\n-> ([b] -> Encoding)\n-> [f a b]\n-> Encoding\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftToEncodingList2\",\"kind\":3,\"detail\":\"forall (f :: * -> * -> *).\\nToJSON2 f =>\\nforall a b.\\n(a -> Encoding)\\n-> ([a] -> Encoding)\\n-> (b -> Encoding)\\n-> ([b] -> Encoding)\\n-> [f a b]\\n-> Encoding\\nData.Aeson.Utils\",\"data\":\"liftToEncodingList2 module:Data.Aeson.Utils is:exact\"}}","word":"liftToEncodingList2"},{"abbr":"liftToJSON2","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Value)\n-> ([a] -> Value)\n-> (b -> Value)\n-> ([b] -> Value)\n-> f a b\n-> Value\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftToJSON2\",\"kind\":3,\"detail\":\"forall (f :: * -> * -> *).\\nToJSON2 f =>\\nforall a b.\\n(a -> Value)\\n-> ([a] -> Value)\\n-> (b -> Value)\\n-> ([b] -> Value)\\n-> f a b\\n-> Value\\nData.Aeson.Utils\",\"data\":\"liftToJSON2 module:Data.Aeson.Utils is:exact\"}}","word":"liftToJSON2"},{"abbr":"liftToJSONList2","dup":1,"icase":1,"info":"","kind":"Function","menu":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Value)\n-> ([a] -> Value)\n-> (b -> Value)\n-> ([b] -> Value)\n-> [f a b]\n-> Value\nData.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"liftToJSONList2\",\"kind\":3,\"detail\":\"forall (f :: * -> * -> *).\\nToJSON2 f =>\\nforall a b.\\n(a -> Value)\\n-> ([a] -> Value)\\n-> (b -> Value)\\n-> ([b] -> Value)\\n-> [f a b]\\n-> Value\\nData.Aeson.Utils\",\"data\":\"liftToJSONList2 module:Data.Aeson.Utils is:exact\"}}","word":"liftToJSONList2"},{"abbr":"ToJSONKeyFunction","dup":1,"icase":1,"info":"","kind":"Class","menu":"Data.Aeson.Utils","user_data":"{\"lspitem\":{\"label\":\"ToJSONKeyFunction\",\"kind\":7,\"detail\":\"Data.Aeson.Utils\",\"data\":\"ToJSONKeyFunction module:Data.Aeson.Utils is:exact\"}}","word":"ToJSONKeyFunction"}],false],"id":25671}
01:03:34 INFO reader-main src/vim.rs:380 <= None {"id": 25671, "jsonrpc": "2.0", "result": 0}
01:03:34 INFO main src/languageclient.rs:2540 End LanguageClient_NCM2OnComplete
01:03:34 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","result":[{"data":"decodeFileStrict module:Data.Aeson.Utils is:exact","detail":"forall a. FromJSON a => FilePath -> IO (Maybe a)\nData.Aeson.Utils","kind":3,"label":"decodeFileStrict"},{"data":"decodeFileStrict' module:Data.Aeson.Utils is:exact","detail":"forall a. FromJSON a => FilePath -> IO (Maybe a)\nData.Aeson.Utils","kind":3,"label":"decodeFileStrict'"},{"data":"eitherDecodeFileStrict module:Data.Aeson.Utils is:exact","detail":"forall a. FromJSON a => FilePath -> IO (Either String a)\nData.Aeson.Utils","kind":3,"label":"eitherDecodeFileStrict"},{"data":"eitherDecodeFileStrict' module:Data.Aeson.Utils is:exact","detail":"forall a. FromJSON a => FilePath -> IO (Either String a)\nData.Aeson.Utils","kind":3,"label":"eitherDecodeFileStrict'"},{"data":"encodeFile module:Data.Aeson.Utils is:exact","detail":"forall a. ToJSON a => FilePath -> a -> IO ()\nData.Aeson.Utils","kind":3,"label":"encodeFile"},{"data":"unsafeToEncoding module:Data.Aeson.Utils is:exact","detail":"forall a. Builder -> Encoding' a\nData.Aeson.Utils","kind":3,"label":"unsafeToEncoding"},{"data":"foldable module:Data.Aeson.Utils is:exact","detail":"forall (t :: * -> *) a. (Foldable t, ToJSON a) => t a -> Encoding\nData.Aeson.Utils","kind":3,"label":"foldable"},{"data":"coerceFromJSONKeyFunction module:Data.Aeson.Utils is:exact","detail":"forall a b.\nCoercible a b =>\nFromJSONKeyFunction a -> FromJSONKeyFunction b\nData.Aeson.Utils","kind":3,"label":"coerceFromJSONKeyFunction"},{"data":"explicitParseField module:Data.Aeson.Utils is:exact","detail":"forall a. (Value -> Parser a) -> Object -> Text -> Parser a\nData.Aeson.Utils","kind":3,"label":"explicitParseField"},{"data":"explicitParseFieldMaybe module:Data.Aeson.Utils is:exact","detail":"forall a. (Value -> Parser a) -> Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils","kind":3,"label":"explicitParseFieldMaybe"},{"data":"explicitParseFieldMaybe' module:Data.Aeson.Utils is:exact","detail":"forall a. (Value -> Parser a) -> Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils","kind":3,"label":"explicitParseFieldMaybe'"},{"data":"fromJSON module:Data.Aeson.Utils is:exact","detail":"forall a. FromJSON a => Value -> Result a\nData.Aeson.Utils","kind":3,"label":"fromJSON"},{"data":"fromJSONKeyCoerce module:Data.Aeson.Utils is:exact","detail":"forall a. Coercible Text a => FromJSONKeyFunction a\nData.Aeson.Utils","kind":3,"label":"fromJSONKeyCoerce"},{"data":"genericLiftParseJSON module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> *) a.\n(Generic1 f, GFromJSON One (Rep1 f)) =>\nOptions\n-> (Value -> Parser a)\n-> (Value -> Parser [a])\n-> Value\n-> Parser (f a)\nData.Aeson.Utils","kind":3,"label":"genericLiftParseJSON"},{"data":"mapFromJSONKeyFunction module:Data.Aeson.Utils is:exact","detail":"forall a b.\n(a -> b) -> FromJSONKeyFunction a -> FromJSONKeyFunction b\nData.Aeson.Utils","kind":3,"label":"mapFromJSONKeyFunction"},{"data":"parseField module:Data.Aeson.Utils is:exact","detail":"forall a. FromJSON a => Object -> Text -> Parser a\nData.Aeson.Utils","kind":3,"label":"parseField"},{"data":"parseFieldMaybe module:Data.Aeson.Utils is:exact","detail":"forall a. FromJSON a => Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils","kind":3,"label":"parseFieldMaybe"},{"data":"parseFieldMaybe' module:Data.Aeson.Utils is:exact","detail":"forall a. FromJSON a => Object -> Text -> Parser (Maybe a)\nData.Aeson.Utils","kind":3,"label":"parseFieldMaybe'"},{"data":"withScientific module:Data.Aeson.Utils is:exact","detail":"forall a. String -> (Scientific -> Parser a) -> Value -> Parser a\nData.Aeson.Utils","kind":3,"label":"withScientific"},{"data":"defaultOptions module:Data.Aeson.Utils is:exact","detail":"Options\nData.Aeson.Utils","kind":3,"label":"defaultOptions"},{"data":"defaultTaggedObject module:Data.Aeson.Utils is:exact","detail":"SumEncoding\nData.Aeson.Utils","kind":3,"label":"defaultTaggedObject"},{"data":"modifyFailure module:Data.Aeson.Utils is:exact","detail":"forall a. (String -> String) -> Parser a -> Parser a\nData.Aeson.Utils","kind":3,"label":"modifyFailure"},{"data":"contramapToJSONKeyFunction module:Data.Aeson.Utils is:exact","detail":"forall b a. (b -> a) -> ToJSONKeyFunction a -> ToJSONKeyFunction b\nData.Aeson.Utils","kind":3,"label":"contramapToJSONKeyFunction"},{"data":"genericLiftToEncoding module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> *) a.\n(Generic1 f, GToJSON Encoding One (Rep1 f)) =>\nOptions -> (a -> Encoding) -> ([a] -> Encoding) -> f a -> Encoding\nData.Aeson.Utils","kind":3,"label":"genericLiftToEncoding"},{"data":"genericLiftToJSON module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> *) a.\n(Generic1 f, GToJSON Value One (Rep1 f)) =>\nOptions -> (a -> Value) -> ([a] -> Value) -> f a -> Value\nData.Aeson.Utils","kind":3,"label":"genericLiftToJSON"},{"data":"floatingOrInteger module:Data.Aeson.Utils is:exact","detail":"forall r i. (RealFloat r, Integral i) => Scientific -> Either r i\nData.Aeson.Utils","kind":3,"label":"floatingOrInteger"},{"data":"fromFloatDigits module:Data.Aeson.Utils is:exact","detail":"forall a. RealFloat a => a -> Scientific\nData.Aeson.Utils","kind":3,"label":"fromFloatDigits"},{"data":"fromEncoding module:Data.Aeson.Utils is:exact","detail":"forall tag. Encoding' tag -> Builder\nData.Aeson.Utils","kind":3,"label":"fromEncoding"},{"data":"FromArgs module:Data.Aeson.Utils is:exact","detail":"Data.Aeson.Utils","kind":7,"label":"FromArgs"},{"data":"From1Args module:Data.Aeson.Utils is:exact","detail":"forall a.\n(Value -> Parser a) -> (Value -> Parser [a]) -> FromArgs One a\nData.Aeson.Utils","kind":4,"label":"From1Args"},{"data":"NoFromArgs module:Data.Aeson.Utils is:exact","detail":"forall a. FromArgs Zero a\nData.Aeson.Utils","kind":4,"label":"NoFromArgs"},{"data":"FromJSON module:Data.Aeson.Utils is:exact","detail":"Data.Aeson.Utils","kind":7,"label":"FromJSON"},{"data":"FromJSON1 module:Data.Aeson.Utils is:exact","detail":"Data.Aeson.Utils","kind":7,"label":"FromJSON1"},{"data":"liftParseJSON module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> *).\nFromJSON1 f =>\nforall a.\n(Value -> Parser a)\n-> (Value -> Parser [a]) -> Value -> Parser (f a)\nData.Aeson.Utils","kind":3,"label":"liftParseJSON"},{"data":"liftParseJSONList module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> *).\nFromJSON1 f =>\nforall a.\n(Value -> Parser a)\n-> (Value -> Parser [a]) -> Value -> Parser [f a]\nData.Aeson.Utils","kind":3,"label":"liftParseJSONList"},{"data":"FromJSON2 module:Data.Aeson.Utils is:exact","detail":"Data.Aeson.Utils","kind":7,"label":"FromJSON2"},{"data":"liftParseJSON2 module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> * -> *).\nFromJSON2 f =>\nforall a b.\n(Value -> Parser a)\n-> (Value -> Parser [a])\n-> (Value -> Parser b)\n-> (Value -> Parser [b])\n-> Value\n-> Parser (f a b)\nData.Aeson.Utils","kind":3,"label":"liftParseJSON2"},{"data":"liftParseJSONList2 module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> * -> *).\nFromJSON2 f =>\nforall a b.\n(Value -> Parser a)\n-> (Value -> Parser [a])\n-> (Value -> Parser b)\n-> (Value -> Parser [b])\n-> Value\n-> Parser [f a b]\nData.Aeson.Utils","kind":3,"label":"liftParseJSONList2"},{"data":"FromJSONKey module:Data.Aeson.Utils is:exact","detail":"Data.Aeson.Utils","kind":7,"label":"FromJSONKey"},{"data":"fromJSONKey module:Data.Aeson.Utils is:exact","detail":"forall a. FromJSONKey a => FromJSONKeyFunction a\nData.Aeson.Utils","kind":3,"label":"fromJSONKey"},{"data":"fromJSONKeyList module:Data.Aeson.Utils is:exact","detail":"forall a. FromJSONKey a => FromJSONKeyFunction [a]\nData.Aeson.Utils","kind":3,"label":"fromJSONKeyList"},{"data":"FromJSONKeyFunction module:Data.Aeson.Utils is:exact","detail":"Data.Aeson.Utils","kind":7,"label":"FromJSONKeyFunction"},{"data":"FromJSONKeyCoerce module:Data.Aeson.Utils is:exact","detail":"forall a. CoerceText a -> FromJSONKeyFunction a\nData.Aeson.Utils","kind":4,"label":"FromJSONKeyCoerce"},{"data":"FromJSONKeyText module:Data.Aeson.Utils is:exact","detail":"forall a. (Text -> a) -> FromJSONKeyFunction a\nData.Aeson.Utils","kind":4,"label":"FromJSONKeyText"},{"data":"FromJSONKeyTextParser module:Data.Aeson.Utils is:exact","detail":"forall a. (Text -> Parser a) -> FromJSONKeyFunction a\nData.Aeson.Utils","kind":4,"label":"FromJSONKeyTextParser"},{"data":"FromJSONKeyValue module:Data.Aeson.Utils is:exact","detail":"forall a. (Value -> Parser a) -> FromJSONKeyFunction a\nData.Aeson.Utils","kind":4,"label":"FromJSONKeyValue"},{"data":"GFromJSON module:Data.Aeson.Utils is:exact","detail":"Data.Aeson.Utils","kind":7,"label":"GFromJSON"},{"data":"fromDotNetTime module:Data.Aeson.Utils is:exact","detail":"DotNetTime -> UTCTime\nData.Aeson.Utils","kind":3,"label":"fromDotNetTime"},{"data":"constructorTagModifier module:Data.Aeson.Utils is:exact","detail":"Options -> String -> String\nData.Aeson.Utils","kind":3,"label":"constructorTagModifier"},{"data":"fieldLabelModifier module:Data.Aeson.Utils is:exact","detail":"Options -> String -> String\nData.Aeson.Utils","kind":3,"label":"fieldLabelModifier"},{"data":"omitNothingFields module:Data.Aeson.Utils is:exact","detail":"Options -> Bool\nData.Aeson.Utils","kind":3,"label":"omitNothingFields"},{"data":"ObjectWithSingleField module:Data.Aeson.Utils is:exact","detail":"SumEncoding\nData.Aeson.Utils","kind":4,"label":"ObjectWithSingleField"},{"data":"contentsFieldName module:Data.Aeson.Utils is:exact","detail":"SumEncoding -> String\nData.Aeson.Utils","kind":3,"label":"contentsFieldName"},{"data":"tagFieldName module:Data.Aeson.Utils is:exact","detail":"SumEncoding -> String\nData.Aeson.Utils","kind":3,"label":"tagFieldName"},{"data":"liftToEncoding module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Encoding) -> ([a] -> Encoding) -> f a -> Encoding\nData.Aeson.Utils","kind":3,"label":"liftToEncoding"},{"data":"liftToEncodingList module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Encoding) -> ([a] -> Encoding) -> [f a] -> Encoding\nData.Aeson.Utils","kind":3,"label":"liftToEncodingList"},{"data":"liftToJSON module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Value) -> ([a] -> Value) -> f a -> Value\nData.Aeson.Utils","kind":3,"label":"liftToJSON"},{"data":"liftToJSONList module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> *).\nToJSON1 f =>\nforall a. (a -> Value) -> ([a] -> Value) -> [f a] -> Value\nData.Aeson.Utils","kind":3,"label":"liftToJSONList"},{"data":"liftToEncoding2 module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Encoding)\n-> ([a] -> Encoding)\n-> (b -> Encoding)\n-> ([b] -> Encoding)\n-> f a b\n-> Encoding\nData.Aeson.Utils","kind":3,"label":"liftToEncoding2"},{"data":"liftToEncodingList2 module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Encoding)\n-> ([a] -> Encoding)\n-> (b -> Encoding)\n-> ([b] -> Encoding)\n-> [f a b]\n-> Encoding\nData.Aeson.Utils","kind":3,"label":"liftToEncodingList2"},{"data":"liftToJSON2 module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Value)\n-> ([a] -> Value)\n-> (b -> Value)\n-> ([b] -> Value)\n-> f a b\n-> Value\nData.Aeson.Utils","kind":3,"label":"liftToJSON2"},{"data":"liftToJSONList2 module:Data.Aeson.Utils is:exact","detail":"forall (f :: * -> * -> *).\nToJSON2 f =>\nforall a b.\n(a -> Value)\n-> ([a] -> Value)\n-> (b -> Value)\n-> ([b] -> Value)\n-> [f a b]\n-> Value\nData.Aeson.Utils","kind":3,"label":"liftToJSONList2"},{"data":"ToJSONKeyFunction module:Data.Aeson.Utils is:exact","detail":"Data.Aeson.Utils","kind":7,"label":"ToJSONKeyFunction"}],"id":768}
01:03:34 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 42, "LSP#visible_line_start()": 12, "LSP#visible_line_end()": 60, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:03:34 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:03:34 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(42)]
01:03:34 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:03:34 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:47 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 43, "LSP#visible_line_start()": 12, "LSP#visible_line_end()": 60, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:47 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:47 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43)]
01:04:47 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:04:47 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:51 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:51 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:04:51 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:51 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:04:51 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:51 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:04:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25672}
01:04:51 INFO reader-main src/vim.rs:380 <= None {"id": 25672, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> cientifictToInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:04:51 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> cientifictToInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:04:51 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> scientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> cientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:04:51 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 639 ==> 640
01:04:51 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> cientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":640}}}
01:04:51 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:04:51 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:04:51 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[]},"method":"textDocument/publishDiagnostics"}
01:04:51 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:04:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[],"r"],"id":25673}
01:04:51 INFO reader-main src/vim.rs:380 <= None {"id": 25673, "jsonrpc": "2.0", "result": 0}
01:04:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25674}
01:04:51 INFO reader-main src/vim.rs:380 <= None {"id": 25674, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:04:51 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:51 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:04:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25675}
01:04:51 INFO reader-main src/vim.rs:380 <= None {"id": 25675, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 43]}
01:04:51 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43)]
01:04:51 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:04:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25676}
01:04:51 INFO reader-main src/vim.rs:380 <= None {"id": 25676, "jsonrpc": "2.0", "result": [12, 60]}
01:04:51 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:04:51 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:04:51 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:04:51 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:51 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:04:51 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:51 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:04:51 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:51 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:04:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25677}
01:04:51 INFO reader-main src/vim.rs:380 <= None {"id": 25677, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> ientifictToInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:04:51 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> ientifictToInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:04:51 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 640 ==> 641
01:04:51 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> cientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> ientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:04:51 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> ientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":641}}}
01:04:51 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:04:51 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:04:51 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:51 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:04:51 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:51 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:04:51 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:51 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:04:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25678}
01:04:51 INFO reader-main src/vim.rs:380 <= None {"id": 25678, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> entifictToInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:04:51 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> entifictToInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:04:51 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 641 ==> 642
01:04:51 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> ientifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> entifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:04:51 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> entifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":642}}}
01:04:51 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:04:51 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:04:52 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:52 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:04:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:52 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:04:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:52 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:04:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25679}
01:04:52 INFO reader-main src/vim.rs:380 <= None {"id": 25679, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> ntifictToInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:04:52 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> ntifictToInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:04:52 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 642 ==> 643
01:04:52 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> entifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> ntifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:04:52 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> ntifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":643}}}
01:04:52 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:04:52 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:04:52 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:52 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:04:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:52 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:04:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:52 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:04:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25680}
01:04:52 INFO reader-main src/vim.rs:380 <= None {"id": 25680, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> tifictToInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:04:52 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> tifictToInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:04:52 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 643 ==> 644
01:04:52 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> ntifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> tifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:04:52 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> tifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":644}}}
01:04:52 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:04:52 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:04:52 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:52 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:04:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:52 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:04:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:52 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:04:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25681}
01:04:52 INFO reader-main src/vim.rs:380 <= None {"id": 25681, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> ifictToInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:04:52 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> ifictToInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:04:52 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 644 ==> 645
01:04:52 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> tifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> ifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:04:52 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> ifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":645}}}
01:04:52 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:04:52 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:04:52 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[{"severity":1,"range":{"start":{"line":43,"character":47},"end":{"line":43,"character":62}},"source":"ghcmod","message":"• Variable not in scope:\n    cientifictToInt :: Either Double Integer -> a0\n• Perhaps you meant ‘scientifictToInt’ (line 32)"}]},"method":"textDocument/publishDiagnostics"}
01:04:52 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:04:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":48,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":44,"nr":null,"text":"• Variable not in scope:\n    cientifictToInt :: Either Double Integer -> a0\n• Perhaps you meant ‘scientifictToInt’ (line 32)","type":"E"}],"r"],"id":25682}
01:04:52 INFO reader-main src/vim.rs:380 <= None {"id": 25682, "jsonrpc": "2.0", "result": 0}
01:04:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25683}
01:04:52 INFO reader-main src/vim.rs:380 <= None {"id": 25683, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:04:52 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:52 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:04:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25684}
01:04:52 INFO reader-main src/vim.rs:380 <= None {"id": 25684, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 43]}
01:04:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43)]
01:04:52 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:04:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25685}
01:04:52 INFO reader-main src/vim.rs:380 <= None {"id": 25685, "jsonrpc": "2.0", "result": [12, 60]}
01:04:52 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:04:52 INFO main src/languageclient.rs:2270 Updating signs: ["sign place 75172 line=44 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"]
01:04:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"execute","params":["sign place 75172 line=44 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"],"id":25686}
01:04:52 INFO reader-main src/vim.rs:380 <= None {"id": 25686, "jsonrpc": "2.0", "result": 0}
01:04:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"nvim_buf_clear_highlight","params":[0,1,12,60]}
01:04:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:AddHighlights","params":[1,[{"character_end":62,"character_start":47,"group":"ALEError","line":43,"text":"ifictToInt |> s"}]]}
01:04:52 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:04:52 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:04:52 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:52 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:04:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:52 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:04:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:52 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:04:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25687}
01:04:52 INFO reader-main src/vim.rs:380 <= None {"id": 25687, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> fictToInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:04:52 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> fictToInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:04:52 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> ifictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> fictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:04:52 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 645 ==> 646
01:04:52 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> fictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":646}}}
01:04:52 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:04:52 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:04:52 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[{"severity":1,"range":{"start":{"line":43,"character":47},"end":{"line":43,"character":62}},"source":"ghcmod","message":"• Variable not in scope:\n    cientifictToInt :: Either Double Integer -> a0\n• Perhaps you meant ‘scientifictToInt’ (line 32)"}]},"method":"textDocument/publishDiagnostics"}
01:04:52 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:04:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":48,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":44,"nr":null,"text":"• Variable not in scope:\n    cientifictToInt :: Either Double Integer -> a0\n• Perhaps you meant ‘scientifictToInt’ (line 32)","type":"E"}],"r"],"id":25688}
01:04:52 INFO reader-main src/vim.rs:380 <= None {"id": 25688, "jsonrpc": "2.0", "result": 0}
01:04:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25689}
01:04:52 INFO reader-main src/vim.rs:380 <= None {"id": 25689, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:04:52 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:52 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:04:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25690}
01:04:52 INFO reader-main src/vim.rs:380 <= None {"id": 25690, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 43]}
01:04:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43)]
01:04:52 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:04:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25691}
01:04:52 INFO reader-main src/vim.rs:380 <= None {"id": 25691, "jsonrpc": "2.0", "result": [12, 60]}
01:04:52 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:04:52 INFO main src/languageclient.rs:2270 Updating signs: ["sign unplace 75172 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", "sign place 75172 line=44 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"]
01:04:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"execute","params":["sign unplace 75172 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","sign place 75172 line=44 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"],"id":25692}
01:04:52 INFO reader-main src/vim.rs:380 <= None {"id": 25692, "jsonrpc": "2.0", "result": 0}
01:04:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"nvim_buf_clear_highlight","params":[0,1,12,60]}
01:04:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:AddHighlights","params":[1,[{"character_end":62,"character_start":47,"group":"ALEError","line":43,"text":"fictToInt |> sh"}]]}
01:04:52 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:04:52 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:04:52 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:52 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:04:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:52 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:04:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:52 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:04:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25693}
01:04:52 INFO reader-main src/vim.rs:380 <= None {"id": 25693, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> ictToInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:04:52 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> ictToInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:04:52 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> fictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> ictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:04:52 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 646 ==> 647
01:04:52 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> ictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":647}}}
01:04:52 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:04:52 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:04:52 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:52 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:04:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:52 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:04:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:52 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:04:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25694}
01:04:52 INFO reader-main src/vim.rs:380 <= None {"id": 25694, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> ctToInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:04:52 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> ctToInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:04:52 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> ictToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> ctToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:04:52 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 647 ==> 648
01:04:52 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> ctToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":648}}}
01:04:52 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:04:52 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:04:53 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[{"severity":1,"range":{"start":{"line":43,"character":47},"end":{"line":43,"character":57}},"source":"ghcmod","message":"Variable not in scope: ifictToInt :: Either Double Integer -> a0"}]},"method":"textDocument/publishDiagnostics"}
01:04:53 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":48,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":44,"nr":null,"text":"Variable not in scope: ifictToInt :: Either Double Integer -> a0","type":"E"}],"r"],"id":25695}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25695, "jsonrpc": "2.0", "result": 0}
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25696}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25696, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:04:53 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:53 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25697}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25697, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 43]}
01:04:53 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43)]
01:04:53 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25698}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25698, "jsonrpc": "2.0", "result": [12, 60]}
01:04:53 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:04:53 INFO main src/languageclient.rs:2270 Updating signs: ["sign unplace 75172 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", "sign place 75172 line=44 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"]
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"execute","params":["sign unplace 75172 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","sign place 75172 line=44 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"],"id":25699}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25699, "jsonrpc": "2.0", "result": 0}
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"nvim_buf_clear_highlight","params":[0,1,12,60]}
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:AddHighlights","params":[1,[{"character_end":57,"character_start":47,"group":"ALEError","line":43,"text":"ctToInt |>"}]]}
01:04:53 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:04:53 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:04:53 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[{"severity":1,"range":{"start":{"line":43,"character":47},"end":{"line":43,"character":57}},"source":"ghcmod","message":"Variable not in scope: ifictToInt :: Either Double Integer -> a0"}]},"method":"textDocument/publishDiagnostics"}
01:04:53 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":48,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":44,"nr":null,"text":"Variable not in scope: ifictToInt :: Either Double Integer -> a0","type":"E"}],"r"],"id":25700}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25700, "jsonrpc": "2.0", "result": 0}
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25701}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25701, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:04:53 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:53 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25702}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25702, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 43]}
01:04:53 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43)]
01:04:53 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25703}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25703, "jsonrpc": "2.0", "result": [12, 60]}
01:04:53 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:04:53 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:04:53 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:04:53 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:53 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:04:53 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:53 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:04:53 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:53 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25704}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25704, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> tToInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:04:53 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> tToInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:04:53 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> ctToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> tToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:04:53 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 648 ==> 649
01:04:53 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> tToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":649}}}
01:04:53 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:04:53 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:04:53 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:53 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:04:53 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:53 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:04:53 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:53 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25705}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25705, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> ToInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:04:53 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> ToInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:04:53 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> tToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> ToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:04:53 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 649 ==> 650
01:04:53 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> ToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":650}}}
01:04:53 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:04:53 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:04:53 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[{"severity":1,"range":{"start":{"line":43,"character":47},"end":{"line":43,"character":54}},"source":"ghcmod","message":"Variable not in scope: ctToInt :: Either Double Integer -> a0"}]},"method":"textDocument/publishDiagnostics"}
01:04:53 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":48,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":44,"nr":null,"text":"Variable not in scope: ctToInt :: Either Double Integer -> a0","type":"E"}],"r"],"id":25706}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25706, "jsonrpc": "2.0", "result": 0}
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25707}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25707, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:04:53 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:53 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25708}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25708, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 43]}
01:04:53 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43)]
01:04:53 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25709}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25709, "jsonrpc": "2.0", "result": [12, 60]}
01:04:53 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:04:53 INFO main src/languageclient.rs:2270 Updating signs: ["sign unplace 75172 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", "sign place 75172 line=44 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"]
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"execute","params":["sign unplace 75172 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","sign place 75172 line=44 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"],"id":25710}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25710, "jsonrpc": "2.0", "result": 0}
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"nvim_buf_clear_highlight","params":[0,1,12,60]}
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:AddHighlights","params":[1,[{"character_end":54,"character_start":47,"group":"ALEError","line":43,"text":"ToInt |"}]]}
01:04:53 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:04:53 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:04:53 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[{"severity":1,"range":{"start":{"line":43,"character":47},"end":{"line":43,"character":54}},"source":"ghcmod","message":"Variable not in scope: ctToInt :: Either Double Integer -> a0"}]},"method":"textDocument/publishDiagnostics"}
01:04:53 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":48,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":44,"nr":null,"text":"Variable not in scope: ctToInt :: Either Double Integer -> a0","type":"E"}],"r"],"id":25711}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25711, "jsonrpc": "2.0", "result": 0}
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25712}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25712, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:04:53 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:53 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25713}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25713, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 43]}
01:04:53 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43)]
01:04:53 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25714}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25714, "jsonrpc": "2.0", "result": [12, 60]}
01:04:53 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:04:53 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:04:53 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:04:53 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:53 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:04:53 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:53 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:04:53 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:53 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25715}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25715, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> toInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:04:53 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("scientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> toInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:04:53 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 650 ==> 651
01:04:53 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> ToInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> toInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:04:53 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> toInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":651}}}
01:04:53 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:04:53 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:04:53 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[{"severity":1,"range":{"start":{"line":43,"character":47},"end":{"line":43,"character":52}},"source":"ghcmod","message":"Data constructor not in scope: ToInt :: Either Double Integer -> a0"}]},"method":"textDocument/publishDiagnostics"}
01:04:53 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":48,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":44,"nr":null,"text":"Data constructor not in scope: ToInt :: Either Double Integer -> a0","type":"E"}],"r"],"id":25716}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25716, "jsonrpc": "2.0", "result": 0}
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25717}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25717, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:04:53 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:53 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25718}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25718, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 43]}
01:04:53 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43)]
01:04:53 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25719}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25719, "jsonrpc": "2.0", "result": [12, 60]}
01:04:53 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:04:53 INFO main src/languageclient.rs:2270 Updating signs: ["sign unplace 75172 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", "sign place 75172 line=44 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"]
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"execute","params":["sign unplace 75172 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","sign place 75172 line=44 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"],"id":25720}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25720, "jsonrpc": "2.0", "result": 0}
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"nvim_buf_clear_highlight","params":[0,1,12,60]}
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:AddHighlights","params":[1,[{"character_end":52,"character_start":47,"group":"ALEError","line":43,"text":"toInt"}]]}
01:04:53 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:04:53 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:04:53 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[{"severity":1,"range":{"start":{"line":43,"character":47},"end":{"line":43,"character":52}},"source":"ghcmod","message":"Data constructor not in scope: ToInt :: Either Double Integer -> a0"}]},"method":"textDocument/publishDiagnostics"}
01:04:53 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":48,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":44,"nr":null,"text":"Data constructor not in scope: ToInt :: Either Double Integer -> a0","type":"E"}],"r"],"id":25721}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25721, "jsonrpc": "2.0", "result": 0}
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25722}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25722, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:04:53 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:53 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25723}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25723, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 43]}
01:04:53 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43)]
01:04:53 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25724}
01:04:53 INFO reader-main src/vim.rs:380 <= None {"id": 25724, "jsonrpc": "2.0", "result": [12, 60]}
01:04:53 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:04:53 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:04:53 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:04:54 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[{"severity":1,"range":{"start":{"line":43,"character":47},"end":{"line":43,"character":52}},"source":"ghcmod","message":"Variable not in scope: toInt :: Either Double Integer -> a0"}]},"method":"textDocument/publishDiagnostics"}
01:04:54 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:04:54 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":48,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":44,"nr":null,"text":"Variable not in scope: toInt :: Either Double Integer -> a0","type":"E"}],"r"],"id":25725}
01:04:54 INFO reader-main src/vim.rs:380 <= None {"id": 25725, "jsonrpc": "2.0", "result": 0}
01:04:54 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25726}
01:04:54 INFO reader-main src/vim.rs:380 <= None {"id": 25726, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:04:54 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:54 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:04:54 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25727}
01:04:54 INFO reader-main src/vim.rs:380 <= None {"id": 25727, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 43]}
01:04:54 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(43)]
01:04:54 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:04:54 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25728}
01:04:54 INFO reader-main src/vim.rs:380 <= None {"id": 25728, "jsonrpc": "2.0", "result": [12, 60]}
01:04:54 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:04:54 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:54 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:04:54 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:04:55 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 42, "LSP#visible_line_start()": 12, "LSP#visible_line_end()": 60, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:55 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:55 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(42)]
01:04:55 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:04:55 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:55 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 41, "LSP#visible_line_start()": 12, "LSP#visible_line_end()": 60, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:55 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:55 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(41)]
01:04:55 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:04:55 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:55 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 40, "LSP#visible_line_start()": 12, "LSP#visible_line_end()": 60, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:55 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:55 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(40)]
01:04:55 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:04:55 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:55 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 39, "LSP#visible_line_start()": 12, "LSP#visible_line_end()": 60, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:55 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:55 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(39)]
01:04:55 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:04:55 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:55 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 38, "LSP#visible_line_start()": 12, "LSP#visible_line_end()": 60, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:55 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:55 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(38)]
01:04:55 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:04:55 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:56 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 37, "LSP#visible_line_start()": 12, "LSP#visible_line_end()": 60, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:56 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:56 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(37)]
01:04:56 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:04:56 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:56 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 36, "LSP#visible_line_start()": 12, "LSP#visible_line_end()": 60, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:56 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:56 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(36)]
01:04:56 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(12), Number(60)]
01:04:56 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:56 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 35, "LSP#visible_line_start()": 11, "LSP#visible_line_end()": 59, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:56 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:56 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(35)]
01:04:56 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(11), Number(59)]
01:04:56 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:56 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 34, "LSP#visible_line_start()": 10, "LSP#visible_line_end()": 58, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:56 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:56 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(34)]
01:04:56 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(10), Number(58)]
01:04:56 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:56 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 33, "LSP#visible_line_start()": 9, "LSP#visible_line_end()": 57, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:56 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:56 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(33)]
01:04:56 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(9), Number(57)]
01:04:56 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:56 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 32, "LSP#visible_line_start()": 8, "LSP#visible_line_end()": 56, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:56 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:56 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(32)]
01:04:56 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(8), Number(56)]
01:04:56 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:56 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 31, "LSP#visible_line_start()": 7, "LSP#visible_line_end()": 55, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:56 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:56 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(31)]
01:04:56 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(7), Number(55)]
01:04:56 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:56 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 30, "LSP#visible_line_start()": 6, "LSP#visible_line_end()": 54, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:56 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:56 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(30)]
01:04:56 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(6), Number(54)]
01:04:56 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:57 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:57 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:04:57 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:57 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:04:57 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:57 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:04:57 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25729}
01:04:57 INFO reader-main src/vim.rs:380 <= None {"id": 25729, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "toInt :: (RealFloat r, Integral i) => Either r i -> Int", "scientifictToInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> toInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:04:57 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("toInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("scientifictToInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> toInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:04:57 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\nscientifictToInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> toInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\ntoInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> toInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:04:57 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 651 ==> 652
01:04:57 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\ntoInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> toInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":652}}}
01:04:57 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:04:57 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:04:58 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 31, "LSP#visible_line_start()": 7, "LSP#visible_line_end()": 55, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:58 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:58 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(31)]
01:04:58 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(7), Number(55)]
01:04:58 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:58 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:58 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:04:58 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:58 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:04:58 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:58 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:04:58 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25730}
01:04:58 INFO reader-main src/vim.rs:380 <= None {"id": 25730, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "toInt :: (RealFloat r, Integral i) => Either r i -> Int", "toInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> toInt |> show |>", "            T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:04:58 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("toInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("toInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> toInt |> show |>"), String("            T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:04:58 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\ntoInt :: (RealFloat r, Integral i) => Either r i -> Int\nscientifictToInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> toInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\ntoInt :: (RealFloat r, Integral i) => Either r i -> Int\ntoInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> toInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:04:58 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 652 ==> 653
01:04:58 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\ntoInt :: (RealFloat r, Integral i) => Either r i -> Int\ntoInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> toInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":653}}}
01:04:58 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:04:58 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:04:58 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleBufWritePost", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:58 INFO main src/languageclient.rs:2199 Begin languageClient/handleBufWritePost
01:04:58 INFO main src/languageclient.rs:1826 Begin textDocument/didSave
01:04:58 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:58 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}}
01:04:58 INFO main src/languageclient.rs:1844 End textDocument/didSave
01:04:58 INFO main src/languageclient.rs:2201 End languageClient/handleBufWritePost
01:04:59 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:59 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:04:59 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:59 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:04:59 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs")]
01:04:59 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:04:59 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25731}
01:04:59 INFO reader-main src/vim.rs:380 <= None {"id": 25731, "jsonrpc": "2.0", "result": [["{-# LANGUAGE LambdaCase        #-}", "{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMessage", "  ( IncomingMessage(..)", "  , decode", "  ) where", "", "import           Control.Applicative     ((<|>))", "import           Data.Aeson              (FromJSON, Value, (.:), (.:?))", "import qualified Data.Aeson              as A", "import           Data.Aeson.Types        (Parser)", "import qualified Data.Aeson.Utils        as AUtils", "import qualified Data.ByteString.Lazy    as BS", "import qualified Data.HashMap.Strict     as HM", "import           Data.Text               (Text)", "import qualified Data.Text               as T", "import           LSP.Data.IncomingMethod (IncomingMethod)", "import           LSP.Data.Params         (Params)", "import           Misc                    ((<|), (|>))", "", "data IncomingMessage", "  = RequestMessage Text", "                   IncomingMethod", "  | NotificationMessage IncomingMethod", "  deriving (Show)", "", "jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text", "jsonrpcDecoder v = v .: \"jsonrpc\"", "", "toInt :: (RealFloat r, Integral i) => Either r i -> Int", "toInt num =", "  case num of", "    Left float     -> fromIntegral (round float)", "    Right integral -> fromIntegral integral", "", "requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "requestMessageDecoder v =", "  let id = HM.lookup \"id\" v", "  in case id of", "       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)", "       Just (A.Number num) ->", "         RequestMessage", "           (num |> AUtils.floatingOrInteger |> toInt |> show |> T.pack) <$>", "         A.parseJSON (A.Object v)", "       Just _ -> fail \"\\\"id\\\" must be string or number\"", "       Nothing -> fail \"\\\"id\\\" is required for a request message\"", "", "notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage", "notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)", "", "instance FromJSON IncomingMessage where", "  parseJSON =", "    A.withObject \"Incoming Message\" $ \\v ->", "      jsonrpcDecoder v >>= \\case", "        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v", "        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"", "", "decode :: BS.ByteString -> Either String IncomingMessage", "decode = A.eitherDecode'", ""]]}
01:04:59 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE LambdaCase        #-}"), String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMessage"), String("  ( IncomingMessage(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Control.Applicative     ((<|>))"), String("import           Data.Aeson              (FromJSON, Value, (.:), (.:?))"), String("import qualified Data.Aeson              as A"), String("import           Data.Aeson.Types        (Parser)"), String("import qualified Data.Aeson.Utils        as AUtils"), String("import qualified Data.ByteString.Lazy    as BS"), String("import qualified Data.HashMap.Strict     as HM"), String("import           Data.Text               (Text)"), String("import qualified Data.Text               as T"), String("import           LSP.Data.IncomingMethod (IncomingMethod)"), String("import           LSP.Data.Params         (Params)"), String("import           Misc                    ((<|), (|>))"), String(""), String("data IncomingMessage"), String("  = RequestMessage Text"), String("                   IncomingMethod"), String("  | NotificationMessage IncomingMethod"), String("  deriving (Show)"), String(""), String("jsonrpcDecoder :: HM.HashMap Text Value -> Parser Text"), String("jsonrpcDecoder v = v .: \"jsonrpc\""), String(""), String("toInt :: (RealFloat r, Integral i) => Either r i -> Int"), String("toInt num ="), String("  case num of"), String("    Left float     -> fromIntegral (round float)"), String("    Right integral -> fromIntegral integral"), String(""), String("requestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("requestMessageDecoder v ="), String("  let id = HM.lookup \"id\" v"), String("  in case id of"), String("       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)"), String("       Just (A.Number num) ->"), String("         RequestMessage"), String("           (num |> AUtils.floatingOrInteger |> toInt |> show |> T.pack) <$>"), String("         A.parseJSON (A.Object v)"), String("       Just _ -> fail \"\\\"id\\\" must be string or number\""), String("       Nothing -> fail \"\\\"id\\\" is required for a request message\""), String(""), String("notificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage"), String("notificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)"), String(""), String("instance FromJSON IncomingMessage where"), String("  parseJSON ="), String("    A.withObject \"Incoming Message\" $ \\v ->"), String("      jsonrpcDecoder v >>= \\case"), String("        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v"), String("        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\""), String(""), String("decode :: BS.ByteString -> Either String IncomingMessage"), String("decode = A.eitherDecode\'"), String("")])]
01:04:59 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.text: "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\ntoInt :: (RealFloat r, Integral i) => Either r i -> Int\ntoInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> toInt |> show |>\n            T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\ntoInt :: (RealFloat r, Integral i) => Either r i -> Int\ntoInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> toInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"
01:04:59 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs.version: 653 ==> 654
01:04:59 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE LambdaCase        #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMessage\n  ( IncomingMessage(..)\n  , decode\n  ) where\n\nimport           Control.Applicative     ((<|>))\nimport           Data.Aeson              (FromJSON, Value, (.:), (.:?))\nimport qualified Data.Aeson              as A\nimport           Data.Aeson.Types        (Parser)\nimport qualified Data.Aeson.Utils        as AUtils\nimport qualified Data.ByteString.Lazy    as BS\nimport qualified Data.HashMap.Strict     as HM\nimport           Data.Text               (Text)\nimport qualified Data.Text               as T\nimport           LSP.Data.IncomingMethod (IncomingMethod)\nimport           LSP.Data.Params         (Params)\nimport           Misc                    ((<|), (|>))\n\ndata IncomingMessage\n  = RequestMessage Text\n                   IncomingMethod\n  | NotificationMessage IncomingMethod\n  deriving (Show)\n\njsonrpcDecoder :: HM.HashMap Text Value -> Parser Text\njsonrpcDecoder v = v .: \"jsonrpc\"\n\ntoInt :: (RealFloat r, Integral i) => Either r i -> Int\ntoInt num =\n  case num of\n    Left float     -> fromIntegral (round float)\n    Right integral -> fromIntegral integral\n\nrequestMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nrequestMessageDecoder v =\n  let id = HM.lookup \"id\" v\n  in case id of\n       Just (A.String text) -> RequestMessage text <$> A.parseJSON (A.Object v)\n       Just (A.Number num) ->\n         RequestMessage\n           (num |> AUtils.floatingOrInteger |> toInt |> show |> T.pack) <$>\n         A.parseJSON (A.Object v)\n       Just _ -> fail \"\\\"id\\\" must be string or number\"\n       Nothing -> fail \"\\\"id\\\" is required for a request message\"\n\nnotificationMessageDecoder :: HM.HashMap Text Value -> Parser IncomingMessage\nnotificationMessageDecoder v = NotificationMessage <$> A.parseJSON (A.Object v)\n\ninstance FromJSON IncomingMessage where\n  parseJSON =\n    A.withObject \"Incoming Message\" $ \\v ->\n      jsonrpcDecoder v >>= \\case\n        \"2.0\" -> requestMessageDecoder v <|> notificationMessageDecoder v\n        _ -> fail \"\\\"jsonrpc\\\" must be \\\"2.0\\\"\"\n\ndecode :: BS.ByteString -> Either String IncomingMessage\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","version":654}}}
01:04:59 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:04:59 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:04:59 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 32, "LSP#visible_line_start()": 8, "LSP#visible_line_end()": 56, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:04:59 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:59 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(32)]
01:04:59 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(8), Number(56)]
01:04:59 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:59 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[{"severity":1,"range":{"start":{"line":43,"character":47},"end":{"line":43,"character":52}},"source":"ghcmod","message":"Variable not in scope: toInt :: Either Double Integer -> a0"}]},"method":"textDocument/publishDiagnostics"}
01:04:59 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:04:59 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":48,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":44,"nr":null,"text":"Variable not in scope: toInt :: Either Double Integer -> a0","type":"E"}],"r"],"id":25732}
01:04:59 INFO reader-main src/vim.rs:380 <= None {"id": 25732, "jsonrpc": "2.0", "result": 0}
01:04:59 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25733}
01:04:59 INFO reader-main src/vim.rs:380 <= None {"id": 25733, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:04:59 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:59 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:04:59 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25734}
01:04:59 INFO reader-main src/vim.rs:380 <= None {"id": 25734, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 32]}
01:04:59 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(32)]
01:04:59 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:04:59 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25735}
01:04:59 INFO reader-main src/vim.rs:380 <= None {"id": 25735, "jsonrpc": "2.0", "result": [8, 56]}
01:04:59 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(8), Number(56)]
01:04:59 INFO main src/languageclient.rs:2270 Updating signs: ["sign unplace 75172 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", "sign place 75172 line=44 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"]
01:04:59 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"execute","params":["sign unplace 75172 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","sign place 75172 line=44 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"],"id":25736}
01:04:59 INFO reader-main src/vim.rs:380 <= None {"id": 25736, "jsonrpc": "2.0", "result": 0}
01:04:59 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:59 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:04:59 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:04:59 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[{"severity":1,"range":{"start":{"line":43,"character":47},"end":{"line":43,"character":52}},"source":"ghcmod","message":"Variable not in scope: toInt :: Either Double Integer -> a0"}]},"method":"textDocument/publishDiagnostics"}
01:04:59 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:04:59 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":48,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","lnum":44,"nr":null,"text":"Variable not in scope: toInt :: Either Double Integer -> a0","type":"E"}],"r"],"id":25737}
01:04:59 INFO reader-main src/vim.rs:380 <= None {"id": 25737, "jsonrpc": "2.0", "result": 0}
01:04:59 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25738}
01:04:59 INFO reader-main src/vim.rs:380 <= None {"id": 25738, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:04:59 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:04:59 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:04:59 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25739}
01:04:59 INFO reader-main src/vim.rs:380 <= None {"id": 25739, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 32]}
01:04:59 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(32)]
01:04:59 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:04:59 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25740}
01:04:59 INFO reader-main src/vim.rs:380 <= None {"id": 25740, "jsonrpc": "2.0", "result": [8, 56]}
01:04:59 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(8), Number(56)]
01:04:59 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:04:59 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:04:59 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:05:00 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 33, "LSP#visible_line_start()": 9, "LSP#visible_line_end()": 57, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:05:00 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:00 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(33)]
01:05:00 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(9), Number(57)]
01:05:00 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:00 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 34, "LSP#visible_line_start()": 10, "LSP#visible_line_end()": 58, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:05:00 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:00 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(34)]
01:05:00 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(10), Number(58)]
01:05:00 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:00 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs","diagnostics":[]},"method":"textDocument/publishDiagnostics"}
01:05:00 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:05:00 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[],"r"],"id":25741}
01:05:00 INFO reader-main src/vim.rs:380 <= None {"id": 25741, "jsonrpc": "2.0", "result": 0}
01:05:00 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25742}
01:05:00 INFO reader-main src/vim.rs:380 <= None {"id": 25742, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}
01:05:00 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:00 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:05:00 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25743}
01:05:00 INFO reader-main src/vim.rs:380 <= None {"id": 25743, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs", 34]}
01:05:00 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(34)]
01:05:00 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:05:00 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25744}
01:05:00 INFO reader-main src/vim.rs:380 <= None {"id": 25744, "jsonrpc": "2.0", "result": [10, 58]}
01:05:00 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(10), Number(58)]
01:05:00 INFO main src/languageclient.rs:2270 Updating signs: ["sign unplace 75172 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"]
01:05:00 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"execute","params":["sign unplace 75172 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"],"id":25745}
01:05:00 INFO reader-main src/vim.rs:380 <= None {"id": 25745, "jsonrpc": "2.0", "result": 0}
01:05:00 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"nvim_buf_clear_highlight","params":[0,1,10,58]}
01:05:00 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:AddHighlights","params":[1,[]]}
01:05:00 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:00 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:05:00 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:05:01 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 35, "LSP#visible_line_start()": 11, "LSP#visible_line_end()": 59, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:05:01 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:01 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(35)]
01:05:01 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(11), Number(59)]
01:05:01 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:02 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 36, "LSP#visible_line_start()": 11, "LSP#visible_line_end()": 59, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:05:02 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:02 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(36)]
01:05:02 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(11), Number(59)]
01:05:02 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:44 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "yaml", "line": 26, "LSP#visible_line_start()": 2, "LSP#visible_line_end()": 50, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml"}}
01:05:44 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:44 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml"), Number(26)]
01:05:44 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(2), Number(50)]
01:05:44 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:46 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleBufWritePost", "jsonrpc": "2.0", "params": {"languageId": "yaml", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml"}}
01:05:46 INFO main src/languageclient.rs:2199 Begin languageClient/handleBufWritePost
01:05:46 INFO main src/languageclient.rs:1826 Begin textDocument/didSave
01:05:46 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("yaml"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml")]
01:05:46 INFO main src/vim.rs:92 => Some("yaml") {"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml"}}}
01:05:47 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleBufDelete", "jsonrpc": "2.0", "params": {"languageId": "yaml", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml"}}
01:05:47 INFO main src/languageclient.rs:2206 Begin languageClient/handleBufWritePost
01:05:47 INFO main src/languageclient.rs:48 gather_args: [Filename] = [String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml")]
01:05:47 DEBUG main src/vim.rs:320 state.signs./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml: [] ==> null
01:05:47 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml: {"languageId":"yaml","text":"name:                elm-language-server\nversion:             0.0.1\ngithub:              \"jaredramirez/elm-language-server\"\nlicense:             BSD3\nauthor:              \"Jared Ramirez\"\nmaintainer:          \"jaredramirez@me.com\"\ncopyright:           \"2018 Jared Ramirez\"\n\nextra-source-files:\n- README.md\n- ChangeLog.md\n\n# Metadata used when publishing your package\n# synopsis:            Short description of your package\n# category:            Web\n\n# To avoid duplicated efforts in documentation and dealing with the\n# complications of embedding Haddock markup inside cabal files, it is\n# common to point users to the README.md file.\ndescription:         Please see the README on GitHub at <https://github.com/jaredramirez/elm-language-server#readme>\n\ndependencies:\n- base >= 4.7 && < 5\n- text\n- aeson\n- aeson-utils\n- unordered-containers\n- bytestring\n- directory\n\nlibrary:\n  source-dirs: src\n\nexecutables:\n  elm-language-server-exe:\n    main:                Main.hs\n    source-dirs:         app\n    ghc-options:\n    - -threaded\n    - -rtsopts\n    - -with-rtsopts=-N\n    dependencies:\n    - elm-language-server\n\ntests:\n  elm-language-server-test:\n    main:                Spec.hs\n    source-dirs:         test\n    ghc-options:\n    - -threaded\n    - -rtsopts\n    - -with-rtsopts=-N\n    dependencies:\n    - elm-language-server\n","uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml","version":1} ==> null
01:05:47 INFO main src/languageclient.rs:1849 Begin textDocument/didClose
01:05:47 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("yaml"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml")]
01:05:47 INFO main src/vim.rs:92 => Some("yaml") {"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/package.yaml"}}}
01:05:47 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 36, "LSP#visible_line_start()": 11, "LSP#visible_line_end()": 59, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"}}
01:05:47 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:47 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMessage.hs"), Number(36)]
01:05:47 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(11), Number(59)]
01:05:47 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:47 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 33, "LSP#visible_line_start()": 0, "LSP#visible_line_end()": 43, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:47 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:47 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(33)]
01:05:47 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:47 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:50 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 34, "LSP#visible_line_start()": 0, "LSP#visible_line_end()": 43, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:50 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:50 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(34)]
01:05:50 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:50 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:50 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:50 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:05:50 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs")]
01:05:50 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:05:50 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs")]
01:05:50 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:05:50 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25746}
01:05:50 INFO reader-main src/vim.rs:380 <= None {"id": 25746, "jsonrpc": "2.0", "result": [["{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMethod", "  ( IncomingMethod(..)", "  , decode", "  ) where", "", "import           Data.Aeson           (FromJSON, Value, (.:))", "import qualified Data.Aeson           as A", "import           Data.Aeson.Types     (Parser)", "import qualified Data.ByteString.Lazy as BS", "import qualified Data.HashMap.Strict  as HM", "import           Data.Text            (Text)", "import           Misc                 ((<|))", "", "-- INITIALIZE --", "initialize :: Text", "initialize = \"initialize\"", "", "newtype InitializeParams =", "  InitializeParams Text", "  deriving (Show)", "", "instance FromJSON InitializeParams where", "  parseJSON =", "    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"", "", "-- METHODS --", "data IncomingMethod =", "  Initialize", "  deriving (Show)", "", "incomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod", "incomingMethodDecoder v key", "  | key == initialize = Initialize", "  | otherwise = fail \"Unknown method\"", "", "instance FromJSON IncomingMethod where", "  parseJSON =", "    A.withObject \"IncomingMethod\" <| \\v ->", "      v .: \"method\" >>= incomingMethodDecoder v", "", "decode :: BS.ByteString -> Either String IncomingMethod", "decode = A.eitherDecode'", ""]]}
01:05:50 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMethod"), String("  ( IncomingMethod(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Data.Aeson           (FromJSON, Value, (.:))"), String("import qualified Data.Aeson           as A"), String("import           Data.Aeson.Types     (Parser)"), String("import qualified Data.ByteString.Lazy as BS"), String("import qualified Data.HashMap.Strict  as HM"), String("import           Data.Text            (Text)"), String("import           Misc                 ((<|))"), String(""), String("-- INITIALIZE --"), String("initialize :: Text"), String("initialize = \"initialize\""), String(""), String("newtype InitializeParams ="), String("  InitializeParams Text"), String("  deriving (Show)"), String(""), String("instance FromJSON InitializeParams where"), String("  parseJSON ="), String("    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\""), String(""), String("-- METHODS --"), String("data IncomingMethod ="), String("  Initialize"), String("  deriving (Show)"), String(""), String("incomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod"), String("incomingMethodDecoder v key"), String("  | key == initialize = Initialize"), String("  | otherwise = fail \"Unknown method\""), String(""), String("instance FromJSON IncomingMethod where"), String("  parseJSON ="), String("    A.withObject \"IncomingMethod\" <| \\v ->"), String("      v .: \"method\" >>= incomingMethodDecoder v"), String(""), String("decode :: BS.ByteString -> Either String IncomingMethod"), String("decode = A.eitherDecode\'"), String("")])]
01:05:50 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs.version: 94 ==> 95
01:05:50 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs.text: "{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"initialize\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize\n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = return Initialize\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"initialize\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize\n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n"
01:05:50 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"initialize\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize\n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","version":95}}}
01:05:50 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:05:50 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:05:50 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","diagnostics":[]},"method":"textDocument/publishDiagnostics"}
01:05:50 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:05:50 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[],"r"],"id":25747}
01:05:50 INFO reader-main src/vim.rs:380 <= None {"id": 25747, "jsonrpc": "2.0", "result": 0}
01:05:50 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25748}
01:05:50 INFO reader-main src/vim.rs:380 <= None {"id": 25748, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}
01:05:50 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:50 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:05:50 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25749}
01:05:50 INFO reader-main src/vim.rs:380 <= None {"id": 25749, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs", 34]}
01:05:50 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(34)]
01:05:50 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:05:50 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25750}
01:05:50 INFO reader-main src/vim.rs:380 <= None {"id": 25750, "jsonrpc": "2.0", "result": [0, 43]}
01:05:50 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:50 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:50 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:05:50 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:05:50 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 29, "LSP#visible_line_start()": 0, "LSP#visible_line_end()": 43, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:50 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:50 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(29)]
01:05:50 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:50 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:50 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:50 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:05:50 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs")]
01:05:50 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:05:50 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs")]
01:05:50 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:05:50 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25751}
01:05:50 INFO reader-main src/vim.rs:380 <= None {"id": 25751, "jsonrpc": "2.0", "result": [["{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMethod", "  ( IncomingMethod(..)", "  , decode", "  ) where", "", "import           Data.Aeson           (FromJSON, Value, (.:))", "import qualified Data.Aeson           as A", "import           Data.Aeson.Types     (Parser)", "import qualified Data.ByteString.Lazy as BS", "import qualified Data.HashMap.Strict  as HM", "import           Data.Text            (Text)", "import           Misc                 ((<|))", "", "-- INITIALIZE --", "initialize :: Text", "initialize = \"initialize\"", "", "newtype InitializeParams =", "  InitializeParams Text", "  deriving (Show)", "", "instance FromJSON InitializeParams where", "  parseJSON =", "    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"", "", "-- METHODS --", "data IncomingMethod =", "  Initialize ", "  deriving (Show)", "", "incomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod", "incomingMethodDecoder v key", "  | key == initialize = Initialize", "  | otherwise = fail \"Unknown method\"", "", "instance FromJSON IncomingMethod where", "  parseJSON =", "    A.withObject \"IncomingMethod\" <| \\v ->", "      v .: \"method\" >>= incomingMethodDecoder v", "", "decode :: BS.ByteString -> Either String IncomingMethod", "decode = A.eitherDecode'", ""]]}
01:05:50 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMethod"), String("  ( IncomingMethod(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Data.Aeson           (FromJSON, Value, (.:))"), String("import qualified Data.Aeson           as A"), String("import           Data.Aeson.Types     (Parser)"), String("import qualified Data.ByteString.Lazy as BS"), String("import qualified Data.HashMap.Strict  as HM"), String("import           Data.Text            (Text)"), String("import           Misc                 ((<|))"), String(""), String("-- INITIALIZE --"), String("initialize :: Text"), String("initialize = \"initialize\""), String(""), String("newtype InitializeParams ="), String("  InitializeParams Text"), String("  deriving (Show)"), String(""), String("instance FromJSON InitializeParams where"), String("  parseJSON ="), String("    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\""), String(""), String("-- METHODS --"), String("data IncomingMethod ="), String("  Initialize "), String("  deriving (Show)"), String(""), String("incomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod"), String("incomingMethodDecoder v key"), String("  | key == initialize = Initialize"), String("  | otherwise = fail \"Unknown method\""), String(""), String("instance FromJSON IncomingMethod where"), String("  parseJSON ="), String("    A.withObject \"IncomingMethod\" <| \\v ->"), String("      v .: \"method\" >>= incomingMethodDecoder v"), String(""), String("decode :: BS.ByteString -> Either String IncomingMethod"), String("decode = A.eitherDecode\'"), String("")])]
01:05:50 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs.version: 95 ==> 96
01:05:50 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs.text: "{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"initialize\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize\n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"initialize\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize \n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n"
01:05:50 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"initialize\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize \n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","version":96}}}
01:05:50 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:05:50 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:05:50 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","diagnostics":[{"severity":1,"range":{"start":{"line":34,"character":24},"end":{"line":34,"character":34}},"source":"ghcmod","message":"• Couldn't match expected type ‘Parser IncomingMethod’\n              with actual type ‘IncomingMethod’\n• In the expression: Initialize\n  In an equation for ‘incomingMethodDecoder’:\n      incomingMethodDecoder v key\n        | key == initialize = Initialize\n        | otherwise = fail \"Unknown method\""}]},"method":"textDocument/publishDiagnostics"}
01:05:50 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:05:50 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":25,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","lnum":35,"nr":null,"text":"• Couldn't match expected type ‘Parser IncomingMethod’\n              with actual type ‘IncomingMethod’\n• In the expression: Initialize\n  In an equation for ‘incomingMethodDecoder’:\n      incomingMethodDecoder v key\n        | key == initialize = Initialize\n        | otherwise = fail \"Unknown method\"","type":"E"}],"r"],"id":25752}
01:05:50 INFO reader-main src/vim.rs:380 <= None {"id": 25752, "jsonrpc": "2.0", "result": 0}
01:05:50 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25753}
01:05:50 INFO reader-main src/vim.rs:380 <= None {"id": 25753, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}
01:05:50 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:50 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:05:50 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25754}
01:05:50 INFO reader-main src/vim.rs:380 <= None {"id": 25754, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs", 29]}
01:05:50 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(29)]
01:05:50 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:05:50 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25755}
01:05:50 INFO reader-main src/vim.rs:380 <= None {"id": 25755, "jsonrpc": "2.0", "result": [0, 43]}
01:05:50 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:50 INFO main src/languageclient.rs:2270 Updating signs: ["sign place 75136 line=35 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"]
01:05:50 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"execute","params":["sign place 75136 line=35 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"],"id":25756}
01:05:50 INFO reader-main src/vim.rs:380 <= None {"id": 25756, "jsonrpc": "2.0", "result": 0}
01:05:50 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"nvim_buf_clear_highlight","params":[0,1,0,43]}
01:05:50 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:AddHighlights","params":[1,[{"character_end":34,"character_start":24,"group":"ALEError","line":34,"text":"Initialize"}]]}
01:05:50 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:50 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:05:50 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:05:51 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","diagnostics":[{"severity":1,"range":{"start":{"line":34,"character":24},"end":{"line":34,"character":34}},"source":"ghcmod","message":"• Couldn't match expected type ‘Parser IncomingMethod’\n              with actual type ‘IncomingMethod’\n• In the expression: Initialize\n  In an equation for ‘incomingMethodDecoder’:\n      incomingMethodDecoder v key\n        | key == initialize = Initialize\n        | otherwise = fail \"Unknown method\""}]},"method":"textDocument/publishDiagnostics"}
01:05:51 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":25,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","lnum":35,"nr":null,"text":"• Couldn't match expected type ‘Parser IncomingMethod’\n              with actual type ‘IncomingMethod’\n• In the expression: Initialize\n  In an equation for ‘incomingMethodDecoder’:\n      incomingMethodDecoder v key\n        | key == initialize = Initialize\n        | otherwise = fail \"Unknown method\"","type":"E"}],"r"],"id":25757}
01:05:51 INFO reader-main src/vim.rs:380 <= None {"id": 25757, "jsonrpc": "2.0", "result": 0}
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25758}
01:05:51 INFO reader-main src/vim.rs:380 <= None {"id": 25758, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}
01:05:51 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:51 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25759}
01:05:51 INFO reader-main src/vim.rs:380 <= None {"id": 25759, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs", 29]}
01:05:51 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(29)]
01:05:51 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25760}
01:05:51 INFO reader-main src/vim.rs:380 <= None {"id": 25760, "jsonrpc": "2.0", "result": [0, 43]}
01:05:51 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:51 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:05:51 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:05:51 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 34, "LSP#visible_line_start()": 0, "LSP#visible_line_end()": 43, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:51 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:51 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(34)]
01:05:51 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:EchoEllipsis","params":["[Error]• Couldn't match expected type ‘Parser IncomingMethod’               with actual type ‘IncomingMethod’ • In the expression: Initialize   In an equation for ‘incomingMethodDecoder’:       incomingMethodDecoder v key         | key == initialize = Initialize         | otherwise = fail \"Unknown method\""]}
01:05:51 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:51 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:51 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:05:51 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs")]
01:05:51 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:05:51 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs")]
01:05:51 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25761}
01:05:51 INFO reader-main src/vim.rs:380 <= None {"id": 25761, "jsonrpc": "2.0", "result": [["{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMethod", "  ( IncomingMethod(..)", "  , decode", "  ) where", "", "import           Data.Aeson           (FromJSON, Value, (.:))", "import qualified Data.Aeson           as A", "import           Data.Aeson.Types     (Parser)", "import qualified Data.ByteString.Lazy as BS", "import qualified Data.HashMap.Strict  as HM", "import           Data.Text            (Text)", "import           Misc                 ((<|))", "", "-- INITIALIZE --", "initialize :: Text", "initialize = \"initialize\"", "", "newtype InitializeParams =", "  InitializeParams Text", "  deriving (Show)", "", "instance FromJSON InitializeParams where", "  parseJSON =", "    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"", "", "-- METHODS --", "data IncomingMethod =", "  Initialize ", "  deriving (Show)", "", "incomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod", "incomingMethodDecoder v key", "  | key == initialize = Initialize <$> v .: \"params\"", "  | otherwise = fail \"Unknown method\"", "", "instance FromJSON IncomingMethod where", "  parseJSON =", "    A.withObject \"IncomingMethod\" <| \\v ->", "      v .: \"method\" >>= incomingMethodDecoder v", "", "decode :: BS.ByteString -> Either String IncomingMethod", "decode = A.eitherDecode'", ""]]}
01:05:51 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMethod"), String("  ( IncomingMethod(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Data.Aeson           (FromJSON, Value, (.:))"), String("import qualified Data.Aeson           as A"), String("import           Data.Aeson.Types     (Parser)"), String("import qualified Data.ByteString.Lazy as BS"), String("import qualified Data.HashMap.Strict  as HM"), String("import           Data.Text            (Text)"), String("import           Misc                 ((<|))"), String(""), String("-- INITIALIZE --"), String("initialize :: Text"), String("initialize = \"initialize\""), String(""), String("newtype InitializeParams ="), String("  InitializeParams Text"), String("  deriving (Show)"), String(""), String("instance FromJSON InitializeParams where"), String("  parseJSON ="), String("    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\""), String(""), String("-- METHODS --"), String("data IncomingMethod ="), String("  Initialize "), String("  deriving (Show)"), String(""), String("incomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod"), String("incomingMethodDecoder v key"), String("  | key == initialize = Initialize <$> v .: \"params\""), String("  | otherwise = fail \"Unknown method\""), String(""), String("instance FromJSON IncomingMethod where"), String("  parseJSON ="), String("    A.withObject \"IncomingMethod\" <| \\v ->"), String("      v .: \"method\" >>= incomingMethodDecoder v"), String(""), String("decode :: BS.ByteString -> Either String IncomingMethod"), String("decode = A.eitherDecode\'"), String("")])]
01:05:51 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs.version: 96 ==> 97
01:05:51 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs.text: "{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"initialize\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize \n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"initialize\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize \n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize <$> v .: \"params\"\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n"
01:05:51 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"initialize\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize \n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize <$> v .: \"params\"\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","version":97}}}
01:05:51 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:05:51 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:05:51 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","diagnostics":[{"severity":1,"range":{"start":{"line":34,"character":24},"end":{"line":34,"character":34}},"source":"ghcmod","message":"• Couldn't match expected type ‘Parser IncomingMethod’\n              with actual type ‘IncomingMethod’\n• In the expression: Initialize\n  In an equation for ‘incomingMethodDecoder’:\n      incomingMethodDecoder v key\n        | key == initialize = Initialize\n        | otherwise = fail \"Unknown method\""}]},"method":"textDocument/publishDiagnostics"}
01:05:51 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":25,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","lnum":35,"nr":null,"text":"• Couldn't match expected type ‘Parser IncomingMethod’\n              with actual type ‘IncomingMethod’\n• In the expression: Initialize\n  In an equation for ‘incomingMethodDecoder’:\n      incomingMethodDecoder v key\n        | key == initialize = Initialize\n        | otherwise = fail \"Unknown method\"","type":"E"}],"r"],"id":25762}
01:05:51 INFO reader-main src/vim.rs:380 <= None {"id": 25762, "jsonrpc": "2.0", "result": 0}
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25763}
01:05:51 INFO reader-main src/vim.rs:380 <= None {"id": 25763, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}
01:05:51 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:51 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25764}
01:05:51 INFO reader-main src/vim.rs:380 <= None {"id": 25764, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs", 34]}
01:05:51 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(34)]
01:05:51 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25765}
01:05:51 INFO reader-main src/vim.rs:380 <= None {"id": 25765, "jsonrpc": "2.0", "result": [0, 43]}
01:05:51 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:51 INFO main src/languageclient.rs:2270 Updating signs: ["sign unplace 75136 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs", "sign place 75136 line=35 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"]
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"execute","params":["sign unplace 75136 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","sign place 75136 line=35 name=LanguageClientError file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"],"id":25766}
01:05:51 INFO reader-main src/vim.rs:380 <= None {"id": 25766, "jsonrpc": "2.0", "result": 0}
01:05:51 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:05:51 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:05:51 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","diagnostics":[{"severity":1,"range":{"start":{"line":34,"character":24},"end":{"line":34,"character":34}},"source":"ghcmod","message":"• Couldn't match expected type ‘Parser IncomingMethod’\n              with actual type ‘IncomingMethod’\n• In the expression: Initialize\n  In an equation for ‘incomingMethodDecoder’:\n      incomingMethodDecoder v key\n        | key == initialize = Initialize\n        | otherwise = fail \"Unknown method\""}]},"method":"textDocument/publishDiagnostics"}
01:05:51 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":25,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","lnum":35,"nr":null,"text":"• Couldn't match expected type ‘Parser IncomingMethod’\n              with actual type ‘IncomingMethod’\n• In the expression: Initialize\n  In an equation for ‘incomingMethodDecoder’:\n      incomingMethodDecoder v key\n        | key == initialize = Initialize\n        | otherwise = fail \"Unknown method\"","type":"E"}],"r"],"id":25767}
01:05:51 INFO reader-main src/vim.rs:380 <= None {"id": 25767, "jsonrpc": "2.0", "result": 0}
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25768}
01:05:51 INFO reader-main src/vim.rs:380 <= None {"id": 25768, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}
01:05:51 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:51 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25769}
01:05:51 INFO reader-main src/vim.rs:380 <= None {"id": 25769, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs", 34]}
01:05:51 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(34)]
01:05:51 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25770}
01:05:51 INFO reader-main src/vim.rs:380 <= None {"id": 25770, "jsonrpc": "2.0", "result": [0, 43]}
01:05:51 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:51 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:05:51 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:05:51 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","diagnostics":[{"severity":1,"range":{"start":{"line":34,"character":24},"end":{"line":34,"character":34}},"source":"ghcmod","message":"• Couldn't match expected type ‘a0 -> IncomingMethod’\n              with actual type ‘IncomingMethod’\n• In the first argument of ‘(<$>)’, namely ‘Initialize’\n  In the expression: Initialize <$> v .: \"params\"\n  In an equation for ‘incomingMethodDecoder’:\n      incomingMethodDecoder v key\n        | key == initialize = Initialize <$> v .: \"params\"\n        | otherwise = fail \"Unknown method\""}]},"method":"textDocument/publishDiagnostics"}
01:05:51 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":25,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","lnum":35,"nr":null,"text":"• Couldn't match expected type ‘a0 -> IncomingMethod’\n              with actual type ‘IncomingMethod’\n• In the first argument of ‘(<$>)’, namely ‘Initialize’\n  In the expression: Initialize <$> v .: \"params\"\n  In an equation for ‘incomingMethodDecoder’:\n      incomingMethodDecoder v key\n        | key == initialize = Initialize <$> v .: \"params\"\n        | otherwise = fail \"Unknown method\"","type":"E"}],"r"],"id":25771}
01:05:51 INFO reader-main src/vim.rs:380 <= None {"id": 25771, "jsonrpc": "2.0", "result": 0}
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25772}
01:05:51 INFO reader-main src/vim.rs:380 <= None {"id": 25772, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}
01:05:51 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:51 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25773}
01:05:51 INFO reader-main src/vim.rs:380 <= None {"id": 25773, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs", 34]}
01:05:51 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(34)]
01:05:51 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25774}
01:05:51 INFO reader-main src/vim.rs:380 <= None {"id": 25774, "jsonrpc": "2.0", "result": [0, 43]}
01:05:51 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:51 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:51 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:05:51 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:05:52 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 29, "LSP#visible_line_start()": 0, "LSP#visible_line_end()": 43, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:52 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(29)]
01:05:52 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:EchoEllipsis","params":[""]}
01:05:52 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:52 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:52 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:05:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs")]
01:05:52 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:05:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs")]
01:05:52 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25775}
01:05:52 INFO reader-main src/vim.rs:380 <= None {"id": 25775, "jsonrpc": "2.0", "result": [["{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMethod", "  ( IncomingMethod(..)", "  , decode", "  ) where", "", "import           Data.Aeson           (FromJSON, Value, (.:))", "import qualified Data.Aeson           as A", "import           Data.Aeson.Types     (Parser)", "import qualified Data.ByteString.Lazy as BS", "import qualified Data.HashMap.Strict  as HM", "import           Data.Text            (Text)", "import           Misc                 ((<|))", "", "-- INITIALIZE --", "initialize :: Text", "initialize = \"initialize\"", "", "newtype InitializeParams =", "  InitializeParams Text", "  deriving (Show)", "", "instance FromJSON InitializeParams where", "  parseJSON =", "    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"", "", "-- METHODS --", "data IncomingMethod =", "  Initialize InitializeParams", "  deriving (Show)", "", "incomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod", "incomingMethodDecoder v key", "  | key == initialize = Initialize <$> v .: \"params\"", "  | otherwise = fail \"Unknown method\"", "", "instance FromJSON IncomingMethod where", "  parseJSON =", "    A.withObject \"IncomingMethod\" <| \\v ->", "      v .: \"method\" >>= incomingMethodDecoder v", "", "decode :: BS.ByteString -> Either String IncomingMethod", "decode = A.eitherDecode'", ""]]}
01:05:52 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMethod"), String("  ( IncomingMethod(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Data.Aeson           (FromJSON, Value, (.:))"), String("import qualified Data.Aeson           as A"), String("import           Data.Aeson.Types     (Parser)"), String("import qualified Data.ByteString.Lazy as BS"), String("import qualified Data.HashMap.Strict  as HM"), String("import           Data.Text            (Text)"), String("import           Misc                 ((<|))"), String(""), String("-- INITIALIZE --"), String("initialize :: Text"), String("initialize = \"initialize\""), String(""), String("newtype InitializeParams ="), String("  InitializeParams Text"), String("  deriving (Show)"), String(""), String("instance FromJSON InitializeParams where"), String("  parseJSON ="), String("    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\""), String(""), String("-- METHODS --"), String("data IncomingMethod ="), String("  Initialize InitializeParams"), String("  deriving (Show)"), String(""), String("incomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod"), String("incomingMethodDecoder v key"), String("  | key == initialize = Initialize <$> v .: \"params\""), String("  | otherwise = fail \"Unknown method\""), String(""), String("instance FromJSON IncomingMethod where"), String("  parseJSON ="), String("    A.withObject \"IncomingMethod\" <| \\v ->"), String("      v .: \"method\" >>= incomingMethodDecoder v"), String(""), String("decode :: BS.ByteString -> Either String IncomingMethod"), String("decode = A.eitherDecode\'"), String("")])]
01:05:52 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs.version: 97 ==> 98
01:05:52 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs.text: "{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"initialize\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize \n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize <$> v .: \"params\"\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"initialize\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize InitializeParams\n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize <$> v .: \"params\"\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n"
01:05:52 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"initialize\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize InitializeParams\n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize <$> v .: \"params\"\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","version":98}}}
01:05:52 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:05:52 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:05:52 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","diagnostics":[{"severity":4,"range":{"start":{"line":28,"character":0},"end":{"line":30,"character":17}},"code":"Use newtype instead of data","source":"hlint","message":"Use newtype instead of data\nFound:\n  data IncomingMethod = Initialize InitializeParams\n                        deriving (Show)\nWhy not:\n  newtype IncomingMethod = Initialize InitializeParams\n                           deriving (Show)\ndecreases laziness\n"},{"severity":1,"range":{"start":{"line":34,"character":24},"end":{"line":34,"character":34}},"source":"ghcmod","message":"• Couldn't match expected type ‘a0 -> IncomingMethod’\n              with actual type ‘IncomingMethod’\n• In the first argument of ‘(<$>)’, namely ‘Initialize’\n  In the expression: Initialize <$> v .: \"params\"\n  In an equation for ‘incomingMethodDecoder’:\n      incomingMethodDecoder v key\n        | key == initialize = Initialize <$> v .: \"params\"\n        | otherwise = fail \"Unknown method\""}]},"method":"textDocument/publishDiagnostics"}
01:05:52 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":1,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","lnum":29,"nr":"Use newtype instead of data","text":"Use newtype instead of data\nFound:\n  data IncomingMethod = Initialize InitializeParams\n                        deriving (Show)\nWhy not:\n  newtype IncomingMethod = Initialize InitializeParams\n                           deriving (Show)\ndecreases laziness\n","type":"H"},{"col":25,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","lnum":35,"nr":null,"text":"• Couldn't match expected type ‘a0 -> IncomingMethod’\n              with actual type ‘IncomingMethod’\n• In the first argument of ‘(<$>)’, namely ‘Initialize’\n  In the expression: Initialize <$> v .: \"params\"\n  In an equation for ‘incomingMethodDecoder’:\n      incomingMethodDecoder v key\n        | key == initialize = Initialize <$> v .: \"params\"\n        | otherwise = fail \"Unknown method\"","type":"E"}],"r"],"id":25776}
01:05:52 INFO reader-main src/vim.rs:380 <= None {"id": 25776, "jsonrpc": "2.0", "result": 0}
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25777}
01:05:52 INFO reader-main src/vim.rs:380 <= None {"id": 25777, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}
01:05:52 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:52 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25778}
01:05:52 INFO reader-main src/vim.rs:380 <= None {"id": 25778, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs", 29]}
01:05:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(29)]
01:05:52 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25779}
01:05:52 INFO reader-main src/vim.rs:380 <= None {"id": 25779, "jsonrpc": "2.0", "result": [0, 43]}
01:05:52 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:52 INFO main src/languageclient.rs:2270 Updating signs: ["sign place 75115 line=29 name=LanguageClientHint file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"]
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"execute","params":["sign place 75115 line=29 name=LanguageClientHint file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"],"id":25780}
01:05:52 INFO reader-main src/vim.rs:380 <= None {"id": 25780, "jsonrpc": "2.0", "result": 0}
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"nvim_buf_clear_highlight","params":[0,1,0,43]}
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:AddHighlights","params":[1,[{"character_end":17,"character_start":0,"group":"ALEInfo","line":28,"text":"data IncomingMeth"},{"character_end":34,"character_start":24,"group":"ALEError","line":34,"text":"Initialize"}]]}
01:05:52 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:05:52 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:05:52 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","diagnostics":[{"severity":4,"range":{"start":{"line":28,"character":0},"end":{"line":30,"character":17}},"code":"Use newtype instead of data","source":"hlint","message":"Use newtype instead of data\nFound:\n  data IncomingMethod = Initialize InitializeParams\n                        deriving (Show)\nWhy not:\n  newtype IncomingMethod = Initialize InitializeParams\n                           deriving (Show)\ndecreases laziness\n"}]},"method":"textDocument/publishDiagnostics"}
01:05:52 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":1,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","lnum":29,"nr":"Use newtype instead of data","text":"Use newtype instead of data\nFound:\n  data IncomingMethod = Initialize InitializeParams\n                        deriving (Show)\nWhy not:\n  newtype IncomingMethod = Initialize InitializeParams\n                           deriving (Show)\ndecreases laziness\n","type":"H"}],"r"],"id":25781}
01:05:52 INFO reader-main src/vim.rs:380 <= None {"id": 25781, "jsonrpc": "2.0", "result": 0}
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25782}
01:05:52 INFO reader-main src/vim.rs:380 <= None {"id": 25782, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}
01:05:52 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:52 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25783}
01:05:52 INFO reader-main src/vim.rs:380 <= None {"id": 25783, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs", 29]}
01:05:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(29)]
01:05:52 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25784}
01:05:52 INFO reader-main src/vim.rs:380 <= None {"id": 25784, "jsonrpc": "2.0", "result": [0, 43]}
01:05:52 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:52 INFO main src/languageclient.rs:2270 Updating signs: ["sign unplace 75136 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"]
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"execute","params":["sign unplace 75136 file=/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"],"id":25785}
01:05:52 INFO reader-main src/vim.rs:380 <= None {"id": 25785, "jsonrpc": "2.0", "result": 0}
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"nvim_buf_clear_highlight","params":[0,1,0,43]}
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:AddHighlights","params":[1,[{"character_end":17,"character_start":0,"group":"ALEInfo","line":28,"text":"data IncomingMeth"}]]}
01:05:52 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:05:52 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:05:52 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 17, "LSP#visible_line_start()": 0, "LSP#visible_line_end()": 43, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:52 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(17)]
01:05:52 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:52 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:52 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:52 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:05:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs")]
01:05:52 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:05:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs")]
01:05:52 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25786}
01:05:52 INFO reader-main src/vim.rs:380 <= None {"id": 25786, "jsonrpc": "2.0", "result": [["{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMethod", "  ( IncomingMethod(..)", "  , decode", "  ) where", "", "import           Data.Aeson           (FromJSON, Value, (.:))", "import qualified Data.Aeson           as A", "import           Data.Aeson.Types     (Parser)", "import qualified Data.ByteString.Lazy as BS", "import qualified Data.HashMap.Strict  as HM", "import           Data.Text            (Text)", "import           Misc                 ((<|))", "", "-- INITIALIZE --", "initialize :: Text", "initialize = \"\"", "", "newtype InitializeParams =", "  InitializeParams Text", "  deriving (Show)", "", "instance FromJSON InitializeParams where", "  parseJSON =", "    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"", "", "-- METHODS --", "data IncomingMethod =", "  Initialize InitializeParams", "  deriving (Show)", "", "incomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod", "incomingMethodDecoder v key", "  | key == initialize = Initialize <$> v .: \"params\"", "  | otherwise = fail \"Unknown method\"", "", "instance FromJSON IncomingMethod where", "  parseJSON =", "    A.withObject \"IncomingMethod\" <| \\v ->", "      v .: \"method\" >>= incomingMethodDecoder v", "", "decode :: BS.ByteString -> Either String IncomingMethod", "decode = A.eitherDecode'", ""]]}
01:05:52 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMethod"), String("  ( IncomingMethod(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Data.Aeson           (FromJSON, Value, (.:))"), String("import qualified Data.Aeson           as A"), String("import           Data.Aeson.Types     (Parser)"), String("import qualified Data.ByteString.Lazy as BS"), String("import qualified Data.HashMap.Strict  as HM"), String("import           Data.Text            (Text)"), String("import           Misc                 ((<|))"), String(""), String("-- INITIALIZE --"), String("initialize :: Text"), String("initialize = \"\""), String(""), String("newtype InitializeParams ="), String("  InitializeParams Text"), String("  deriving (Show)"), String(""), String("instance FromJSON InitializeParams where"), String("  parseJSON ="), String("    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\""), String(""), String("-- METHODS --"), String("data IncomingMethod ="), String("  Initialize InitializeParams"), String("  deriving (Show)"), String(""), String("incomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod"), String("incomingMethodDecoder v key"), String("  | key == initialize = Initialize <$> v .: \"params\""), String("  | otherwise = fail \"Unknown method\""), String(""), String("instance FromJSON IncomingMethod where"), String("  parseJSON ="), String("    A.withObject \"IncomingMethod\" <| \\v ->"), String("      v .: \"method\" >>= incomingMethodDecoder v"), String(""), String("decode :: BS.ByteString -> Either String IncomingMethod"), String("decode = A.eitherDecode\'"), String("")])]
01:05:52 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs.version: 98 ==> 99
01:05:52 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs.text: "{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"initialize\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize InitializeParams\n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize <$> v .: \"params\"\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize InitializeParams\n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize <$> v .: \"params\"\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n"
01:05:52 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize InitializeParams\n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize <$> v .: \"params\"\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","version":99}}}
01:05:52 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:05:52 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:05:52 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","diagnostics":[{"severity":4,"range":{"start":{"line":28,"character":0},"end":{"line":30,"character":17}},"code":"Use newtype instead of data","source":"hlint","message":"Use newtype instead of data\nFound:\n  data IncomingMethod = Initialize InitializeParams\n                        deriving (Show)\nWhy not:\n  newtype IncomingMethod = Initialize InitializeParams\n                           deriving (Show)\ndecreases laziness\n"}]},"method":"textDocument/publishDiagnostics"}
01:05:52 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":1,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","lnum":29,"nr":"Use newtype instead of data","text":"Use newtype instead of data\nFound:\n  data IncomingMethod = Initialize InitializeParams\n                        deriving (Show)\nWhy not:\n  newtype IncomingMethod = Initialize InitializeParams\n                           deriving (Show)\ndecreases laziness\n","type":"H"}],"r"],"id":25787}
01:05:52 INFO reader-main src/vim.rs:380 <= None {"id": 25787, "jsonrpc": "2.0", "result": 0}
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25788}
01:05:52 INFO reader-main src/vim.rs:380 <= None {"id": 25788, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}
01:05:52 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:52 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25789}
01:05:52 INFO reader-main src/vim.rs:380 <= None {"id": 25789, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs", 17]}
01:05:52 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(17)]
01:05:52 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25790}
01:05:52 INFO reader-main src/vim.rs:380 <= None {"id": 25790, "jsonrpc": "2.0", "result": [0, 43]}
01:05:52 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:52 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:52 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:05:52 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:05:53 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","diagnostics":[{"severity":4,"range":{"start":{"line":28,"character":0},"end":{"line":30,"character":17}},"code":"Use newtype instead of data","source":"hlint","message":"Use newtype instead of data\nFound:\n  data IncomingMethod = Initialize InitializeParams\n                        deriving (Show)\nWhy not:\n  newtype IncomingMethod = Initialize InitializeParams\n                           deriving (Show)\ndecreases laziness\n"}]},"method":"textDocument/publishDiagnostics"}
01:05:53 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:05:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":1,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","lnum":29,"nr":"Use newtype instead of data","text":"Use newtype instead of data\nFound:\n  data IncomingMethod = Initialize InitializeParams\n                        deriving (Show)\nWhy not:\n  newtype IncomingMethod = Initialize InitializeParams\n                           deriving (Show)\ndecreases laziness\n","type":"H"}],"r"],"id":25791}
01:05:53 INFO reader-main src/vim.rs:380 <= None {"id": 25791, "jsonrpc": "2.0", "result": 0}
01:05:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25792}
01:05:53 INFO reader-main src/vim.rs:380 <= None {"id": 25792, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}
01:05:53 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:53 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:05:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25793}
01:05:53 INFO reader-main src/vim.rs:380 <= None {"id": 25793, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs", 17]}
01:05:53 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(17)]
01:05:53 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:05:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25794}
01:05:53 INFO reader-main src/vim.rs:380 <= None {"id": 25794, "jsonrpc": "2.0", "result": [0, 43]}
01:05:53 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:53 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:05:53 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:05:53 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:53 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:05:53 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs")]
01:05:53 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:05:53 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs")]
01:05:53 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:05:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25795}
01:05:53 INFO reader-main src/vim.rs:380 <= None {"id": 25795, "jsonrpc": "2.0", "result": [["{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMethod", "  ( IncomingMethod(..)", "  , decode", "  ) where", "", "import           Data.Aeson           (FromJSON, Value, (.:))", "import qualified Data.Aeson           as A", "import           Data.Aeson.Types     (Parser)", "import qualified Data.ByteString.Lazy as BS", "import qualified Data.HashMap.Strict  as HM", "import           Data.Text            (Text)", "import           Misc                 ((<|))", "", "-- INITIALIZE --", "initialize :: Text", "initialize = \"initialize\"", "", "newtype InitializeParams =", "  InitializeParams Text", "  deriving (Show)", "", "instance FromJSON InitializeParams where", "  parseJSON =", "    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"", "", "-- METHODS --", "data IncomingMethod =", "  Initialize InitializeParams", "  deriving (Show)", "", "incomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod", "incomingMethodDecoder v key", "  | key == initialize = Initialize <$> v .: \"params\"", "  | otherwise = fail \"Unknown method\"", "", "instance FromJSON IncomingMethod where", "  parseJSON =", "    A.withObject \"IncomingMethod\" <| \\v ->", "      v .: \"method\" >>= incomingMethodDecoder v", "", "decode :: BS.ByteString -> Either String IncomingMethod", "decode = A.eitherDecode'", ""]]}
01:05:53 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMethod"), String("  ( IncomingMethod(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Data.Aeson           (FromJSON, Value, (.:))"), String("import qualified Data.Aeson           as A"), String("import           Data.Aeson.Types     (Parser)"), String("import qualified Data.ByteString.Lazy as BS"), String("import qualified Data.HashMap.Strict  as HM"), String("import           Data.Text            (Text)"), String("import           Misc                 ((<|))"), String(""), String("-- INITIALIZE --"), String("initialize :: Text"), String("initialize = \"initialize\""), String(""), String("newtype InitializeParams ="), String("  InitializeParams Text"), String("  deriving (Show)"), String(""), String("instance FromJSON InitializeParams where"), String("  parseJSON ="), String("    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\""), String(""), String("-- METHODS --"), String("data IncomingMethod ="), String("  Initialize InitializeParams"), String("  deriving (Show)"), String(""), String("incomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod"), String("incomingMethodDecoder v key"), String("  | key == initialize = Initialize <$> v .: \"params\""), String("  | otherwise = fail \"Unknown method\""), String(""), String("instance FromJSON IncomingMethod where"), String("  parseJSON ="), String("    A.withObject \"IncomingMethod\" <| \\v ->"), String("      v .: \"method\" >>= incomingMethodDecoder v"), String(""), String("decode :: BS.ByteString -> Either String IncomingMethod"), String("decode = A.eitherDecode\'"), String("")])]
01:05:53 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs.text: "{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize InitializeParams\n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize <$> v .: \"params\"\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"initialize\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize InitializeParams\n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize <$> v .: \"params\"\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n"
01:05:53 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs.version: 99 ==> 100
01:05:53 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"initialize\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize InitializeParams\n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize <$> v .: \"params\"\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","version":100}}}
01:05:53 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:05:53 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:05:53 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","diagnostics":[{"severity":4,"range":{"start":{"line":28,"character":0},"end":{"line":30,"character":17}},"code":"Use newtype instead of data","source":"hlint","message":"Use newtype instead of data\nFound:\n  data IncomingMethod = Initialize InitializeParams\n                        deriving (Show)\nWhy not:\n  newtype IncomingMethod = Initialize InitializeParams\n                           deriving (Show)\ndecreases laziness\n"}]},"method":"textDocument/publishDiagnostics"}
01:05:53 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:05:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":1,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","lnum":29,"nr":"Use newtype instead of data","text":"Use newtype instead of data\nFound:\n  data IncomingMethod = Initialize InitializeParams\n                        deriving (Show)\nWhy not:\n  newtype IncomingMethod = Initialize InitializeParams\n                           deriving (Show)\ndecreases laziness\n","type":"H"}],"r"],"id":25796}
01:05:53 INFO reader-main src/vim.rs:380 <= None {"id": 25796, "jsonrpc": "2.0", "result": 0}
01:05:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25797}
01:05:53 INFO reader-main src/vim.rs:380 <= None {"id": 25797, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}
01:05:53 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:53 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:05:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25798}
01:05:53 INFO reader-main src/vim.rs:380 <= None {"id": 25798, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs", 17]}
01:05:53 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(17)]
01:05:53 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:05:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25799}
01:05:53 INFO reader-main src/vim.rs:380 <= None {"id": 25799, "jsonrpc": "2.0", "result": [0, 43]}
01:05:53 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:53 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:53 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:05:53 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:05:54 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","diagnostics":[{"severity":4,"range":{"start":{"line":28,"character":0},"end":{"line":30,"character":17}},"code":"Use newtype instead of data","source":"hlint","message":"Use newtype instead of data\nFound:\n  data IncomingMethod = Initialize InitializeParams\n                        deriving (Show)\nWhy not:\n  newtype IncomingMethod = Initialize InitializeParams\n                           deriving (Show)\ndecreases laziness\n"}]},"method":"textDocument/publishDiagnostics"}
01:05:54 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:05:54 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":1,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","lnum":29,"nr":"Use newtype instead of data","text":"Use newtype instead of data\nFound:\n  data IncomingMethod = Initialize InitializeParams\n                        deriving (Show)\nWhy not:\n  newtype IncomingMethod = Initialize InitializeParams\n                           deriving (Show)\ndecreases laziness\n","type":"H"}],"r"],"id":25800}
01:05:54 INFO reader-main src/vim.rs:380 <= None {"id": 25800, "jsonrpc": "2.0", "result": 0}
01:05:54 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25801}
01:05:54 INFO reader-main src/vim.rs:380 <= None {"id": 25801, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}
01:05:54 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:54 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:05:54 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25802}
01:05:54 INFO reader-main src/vim.rs:380 <= None {"id": 25802, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs", 17]}
01:05:54 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(17)]
01:05:54 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:05:54 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25803}
01:05:54 INFO reader-main src/vim.rs:380 <= None {"id": 25803, "jsonrpc": "2.0", "result": [0, 43]}
01:05:54 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:54 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:54 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:05:54 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:05:54 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:54 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:05:54 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs")]
01:05:54 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:05:54 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs")]
01:05:54 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:05:54 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25804}
01:05:54 INFO reader-main src/vim.rs:380 <= None {"id": 25804, "jsonrpc": "2.0", "result": [["{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMethod", "  ( IncomingMethod(..)", "  , decode", "  ) where", "", "import           Data.Aeson           (FromJSON, Value, (.:))", "import qualified Data.Aeson           as A", "import           Data.Aeson.Types     (Parser)", "import qualified Data.ByteString.Lazy as BS", "import qualified Data.HashMap.Strict  as HM", "import           Data.Text            (Text)", "import           Misc                 ((<|))", "", "-- INITIALIZE --", "initialize :: Text", "initialize = \"\"", "", "newtype InitializeParams =", "  InitializeParams Text", "  deriving (Show)", "", "instance FromJSON InitializeParams where", "  parseJSON =", "    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"", "", "-- METHODS --", "data IncomingMethod =", "  Initialize InitializeParams", "  deriving (Show)", "", "incomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod", "incomingMethodDecoder v key", "  | key == initialize = Initialize <$> v .: \"params\"", "  | otherwise = fail \"Unknown method\"", "", "instance FromJSON IncomingMethod where", "  parseJSON =", "    A.withObject \"IncomingMethod\" <| \\v ->", "      v .: \"method\" >>= incomingMethodDecoder v", "", "decode :: BS.ByteString -> Either String IncomingMethod", "decode = A.eitherDecode'", ""]]}
01:05:54 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMethod"), String("  ( IncomingMethod(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Data.Aeson           (FromJSON, Value, (.:))"), String("import qualified Data.Aeson           as A"), String("import           Data.Aeson.Types     (Parser)"), String("import qualified Data.ByteString.Lazy as BS"), String("import qualified Data.HashMap.Strict  as HM"), String("import           Data.Text            (Text)"), String("import           Misc                 ((<|))"), String(""), String("-- INITIALIZE --"), String("initialize :: Text"), String("initialize = \"\""), String(""), String("newtype InitializeParams ="), String("  InitializeParams Text"), String("  deriving (Show)"), String(""), String("instance FromJSON InitializeParams where"), String("  parseJSON ="), String("    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\""), String(""), String("-- METHODS --"), String("data IncomingMethod ="), String("  Initialize InitializeParams"), String("  deriving (Show)"), String(""), String("incomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod"), String("incomingMethodDecoder v key"), String("  | key == initialize = Initialize <$> v .: \"params\""), String("  | otherwise = fail \"Unknown method\""), String(""), String("instance FromJSON IncomingMethod where"), String("  parseJSON ="), String("    A.withObject \"IncomingMethod\" <| \\v ->"), String("      v .: \"method\" >>= incomingMethodDecoder v"), String(""), String("decode :: BS.ByteString -> Either String IncomingMethod"), String("decode = A.eitherDecode\'"), String("")])]
01:05:54 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs.text: "{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"initialize\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize InitializeParams\n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize <$> v .: \"params\"\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize InitializeParams\n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize <$> v .: \"params\"\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n"
01:05:54 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs.version: 100 ==> 101
01:05:54 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize InitializeParams\n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize <$> v .: \"params\"\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","version":101}}}
01:05:54 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:05:54 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:05:55 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleTextChanged", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:55 INFO main src/languageclient.rs:2169 Begin languageClient/handleTextChanged
01:05:55 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs")]
01:05:55 INFO main src/languageclient.rs:1755 Begin textDocument/didChange
01:05:55 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs")]
01:05:55 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["text"]. Exps: ["LSP#text()"]
01:05:55 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#text()]"],"id":25805}
01:05:55 INFO reader-main src/vim.rs:380 <= None {"id": 25805, "jsonrpc": "2.0", "result": [["{-# LANGUAGE OverloadedStrings #-}", "", "module LSP.Data.IncomingMethod", "  ( IncomingMethod(..)", "  , decode", "  ) where", "", "import           Data.Aeson           (FromJSON, Value, (.:))", "import qualified Data.Aeson           as A", "import           Data.Aeson.Types     (Parser)", "import qualified Data.ByteString.Lazy as BS", "import qualified Data.HashMap.Strict  as HM", "import           Data.Text            (Text)", "import           Misc                 ((<|))", "", "-- INITIALIZE --", "initialize :: Text", "initialize = \"initialize\"", "", "newtype InitializeParams =", "  InitializeParams Text", "  deriving (Show)", "", "instance FromJSON InitializeParams where", "  parseJSON =", "    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"", "", "-- METHODS --", "data IncomingMethod =", "  Initialize InitializeParams", "  deriving (Show)", "", "incomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod", "incomingMethodDecoder v key", "  | key == initialize = Initialize <$> v .: \"params\"", "  | otherwise = fail \"Unknown method\"", "", "instance FromJSON IncomingMethod where", "  parseJSON =", "    A.withObject \"IncomingMethod\" <| \\v ->", "      v .: \"method\" >>= incomingMethodDecoder v", "", "decode :: BS.ByteString -> Either String IncomingMethod", "decode = A.eitherDecode'", ""]]}
01:05:55 INFO main src/languageclient.rs:48 gather_args: [Text] = [Array([String("{-# LANGUAGE OverloadedStrings #-}"), String(""), String("module LSP.Data.IncomingMethod"), String("  ( IncomingMethod(..)"), String("  , decode"), String("  ) where"), String(""), String("import           Data.Aeson           (FromJSON, Value, (.:))"), String("import qualified Data.Aeson           as A"), String("import           Data.Aeson.Types     (Parser)"), String("import qualified Data.ByteString.Lazy as BS"), String("import qualified Data.HashMap.Strict  as HM"), String("import           Data.Text            (Text)"), String("import           Misc                 ((<|))"), String(""), String("-- INITIALIZE --"), String("initialize :: Text"), String("initialize = \"initialize\""), String(""), String("newtype InitializeParams ="), String("  InitializeParams Text"), String("  deriving (Show)"), String(""), String("instance FromJSON InitializeParams where"), String("  parseJSON ="), String("    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\""), String(""), String("-- METHODS --"), String("data IncomingMethod ="), String("  Initialize InitializeParams"), String("  deriving (Show)"), String(""), String("incomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod"), String("incomingMethodDecoder v key"), String("  | key == initialize = Initialize <$> v .: \"params\""), String("  | otherwise = fail \"Unknown method\""), String(""), String("instance FromJSON IncomingMethod where"), String("  parseJSON ="), String("    A.withObject \"IncomingMethod\" <| \\v ->"), String("      v .: \"method\" >>= incomingMethodDecoder v"), String(""), String("decode :: BS.ByteString -> Either String IncomingMethod"), String("decode = A.eitherDecode\'"), String("")])]
01:05:55 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs.version: 101 ==> 102
01:05:55 DEBUG main src/vim.rs:320 state.text_documents./Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs.text: "{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize InitializeParams\n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize <$> v .: \"params\"\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n" ==> "{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"initialize\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize InitializeParams\n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize <$> v .: \"params\"\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n"
01:05:55 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"contentChanges":[{"text":"{-# LANGUAGE OverloadedStrings #-}\n\nmodule LSP.Data.IncomingMethod\n  ( IncomingMethod(..)\n  , decode\n  ) where\n\nimport           Data.Aeson           (FromJSON, Value, (.:))\nimport qualified Data.Aeson           as A\nimport           Data.Aeson.Types     (Parser)\nimport qualified Data.ByteString.Lazy as BS\nimport qualified Data.HashMap.Strict  as HM\nimport           Data.Text            (Text)\nimport           Misc                 ((<|))\n\n-- INITIALIZE --\ninitialize :: Text\ninitialize = \"initialize\"\n\nnewtype InitializeParams =\n  InitializeParams Text\n  deriving (Show)\n\ninstance FromJSON InitializeParams where\n  parseJSON =\n    A.withObject \"InitializeParams\" <| \\v -> InitializeParams <$> v .: \"rootUri\"\n\n-- METHODS --\ndata IncomingMethod =\n  Initialize InitializeParams\n  deriving (Show)\n\nincomingMethodDecoder :: HM.HashMap Text Value -> Text -> Parser IncomingMethod\nincomingMethodDecoder v key\n  | key == initialize = Initialize <$> v .: \"params\"\n  | otherwise = fail \"Unknown method\"\n\ninstance FromJSON IncomingMethod where\n  parseJSON =\n    A.withObject \"IncomingMethod\" <| \\v ->\n      v .: \"method\" >>= incomingMethodDecoder v\n\ndecode :: BS.ByteString -> Either String IncomingMethod\ndecode = A.eitherDecode'\n"}],"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","version":102}}}
01:05:55 INFO main src/languageclient.rs:1821 End textDocument/didChange
01:05:55 INFO main src/languageclient.rs:2194 End languageClient/handleTextChanged
01:05:55 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleBufWritePost", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:55 INFO main src/languageclient.rs:2199 Begin languageClient/handleBufWritePost
01:05:55 INFO main src/languageclient.rs:1826 Begin textDocument/didSave
01:05:55 INFO main src/languageclient.rs:48 gather_args: [Buftype, LanguageId, Filename] = [String(""), String("haskell"), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs")]
01:05:55 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}}
01:05:55 INFO main src/languageclient.rs:1844 End textDocument/didSave
01:05:55 INFO main src/languageclient.rs:2201 End languageClient/handleBufWritePost
01:05:56 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 18, "LSP#visible_line_start()": 0, "LSP#visible_line_end()": 43, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:56 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:56 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(18)]
01:05:56 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:56 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:56 INFO reader-haskell src/vim.rs:380 <= Some("haskell") {"jsonrpc":"2.0","params":{"uri":"file:///Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","diagnostics":[{"severity":4,"range":{"start":{"line":28,"character":0},"end":{"line":30,"character":17}},"code":"Use newtype instead of data","source":"hlint","message":"Use newtype instead of data\nFound:\n  data IncomingMethod = Initialize InitializeParams\n                        deriving (Show)\nWhy not:\n  newtype IncomingMethod = Initialize InitializeParams\n                           deriving (Show)\ndecreases laziness\n"}]},"method":"textDocument/publishDiagnostics"}
01:05:56 INFO main src/languageclient.rs:1872 Begin textDocument/publishDiagnostics
01:05:56 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"setqflist","params":[[{"col":1,"filename":"/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs","lnum":29,"nr":"Use newtype instead of data","text":"Use newtype instead of data\nFound:\n  data IncomingMethod = Initialize InitializeParams\n                        deriving (Show)\nWhy not:\n  newtype IncomingMethod = Initialize InitializeParams\n                           deriving (Show)\ndecreases laziness\n","type":"H"}],"r"],"id":25806}
01:05:56 INFO reader-main src/vim.rs:380 <= None {"id": 25806, "jsonrpc": "2.0", "result": 0}
01:05:56 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["LSP#filename()"],"id":25807}
01:05:56 INFO reader-main src/vim.rs:380 <= None {"id": 25807, "jsonrpc": "2.0", "result": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}
01:05:56 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:56 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:05:56 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25808}
01:05:56 INFO reader-main src/vim.rs:380 <= None {"id": 25808, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs", 18]}
01:05:56 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(18)]
01:05:56 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:05:56 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25809}
01:05:56 INFO reader-main src/vim.rs:380 <= None {"id": 25809, "jsonrpc": "2.0", "result": [0, 43]}
01:05:56 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:56 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:56 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"s:ExecuteAutocmd","params":["LanguageClientDiagnosticsChanged"]}
01:05:56 INFO main src/languageclient.rs:1900 End textDocument/publishDiagnostics
01:05:56 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 19, "LSP#visible_line_start()": 0, "LSP#visible_line_end()": 43, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:56 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:56 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(19)]
01:05:56 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:56 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:56 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 20, "LSP#visible_line_start()": 0, "LSP#visible_line_end()": 43, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:56 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:56 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(20)]
01:05:56 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:56 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:56 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 21, "LSP#visible_line_start()": 0, "LSP#visible_line_end()": 43, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:56 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:56 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(21)]
01:05:56 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:56 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:56 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 22, "LSP#visible_line_start()": 0, "LSP#visible_line_end()": 43, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:56 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:56 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(22)]
01:05:56 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:56 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:57 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 23, "LSP#visible_line_start()": 0, "LSP#visible_line_end()": 43, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:57 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:57 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(23)]
01:05:57 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:57 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:57 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 24, "LSP#visible_line_start()": 0, "LSP#visible_line_end()": 43, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:57 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:57 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(24)]
01:05:57 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:57 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:57 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 25, "LSP#visible_line_start()": 0, "LSP#visible_line_end()": 43, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:57 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:57 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(25)]
01:05:57 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:57 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:05:57 INFO reader-main src/vim.rs:380 <= None {"method": "languageClient/handleCursorMoved", "jsonrpc": "2.0", "params": {"languageId": "haskell", "line": 26, "LSP#visible_line_start()": 0, "LSP#visible_line_end()": 43, "buftype": "", "filename": "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"}}
01:05:57 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:05:57 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(26)]
01:05:57 INFO main src/languageclient.rs:48 gather_args: ["LSP#visible_line_start()", "LSP#visible_line_end()"] = [Number(0), Number(43)]
01:05:57 INFO main src/languageclient.rs:2313 End languageClient/handleCursorMoved
01:06:50 INFO reader-main src/vim.rs:380 <= None {"method": "exit", "jsonrpc": "2.0", "params": {"languageId": "haskell", "buftype": ""}}
01:06:50 INFO main src/languageclient.rs:2005 Begin exit
01:06:50 INFO main src/languageclient.rs:48 gather_args: [LanguageId] = [String("haskell")]
01:06:50 INFO main src/vim.rs:92 => Some("haskell") {"jsonrpc":"2.0","method":"exit","params":null}
01:06:50 INFO main src/languageclient.rs:780 Begin cleanup
01:06:50 INFO main src/languageclient.rs:2221 Begin languageClient/handleCursorMoved
01:06:50 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["buftype", "filename", "line"]. Exps: ["&buftype", "LSP#filename()", "LSP#line()"]
01:06:50 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[&buftype, LSP#filename(), LSP#line()]"],"id":25810}
01:06:50 INFO reader-main src/vim.rs:380 <= None {"id": 25810, "jsonrpc": "2.0", "result": ["", "/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs", 26]}
01:06:50 INFO main src/languageclient.rs:48 gather_args: [Buftype, Filename, Line] = [String(""), String("/Users/jaredramirez/dev/src/github.com/jaredramirez/elm-language-server/src/LSP/Data/IncomingMethod.hs"), Number(26)]
01:06:50 INFO main src/languageclient.rs:29 Some arguments are not available. Requesting from vim. Keys: ["LSP#visible_line_start()", "LSP#visible_line_end()"]. Exps: ["LSP#visible_line_start()", "LSP#visible_line_end()"]
01:06:50 INFO main src/vim.rs:92 => None {"jsonrpc":"2.0","method":"eval","params":["[LSP#visible_line_start(), LSP#visible_line_end()]"],"id":25811}
